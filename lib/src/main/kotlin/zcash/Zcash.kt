// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.zcash

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the detils of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.ptr.ByReference
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    @JvmField var capacity: Int = 0

    @JvmField var len: Int = 0

    @JvmField var data: Pointer? = null

    class ByValue : RustBuffer(), Structure.ByValue
    class ByReference : RustBuffer(), Structure.ByReference

    companion object {
        internal fun alloc(size: Int = 0) = rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_rustbuffer_alloc(size, status).also {
                if (it.data == null) {
                    throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=$size)")
                }
            }
        }

        internal fun free(buf: RustBuffer.ByValue) = rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setInt(0, value.capacity)
        pointer.setInt(4, value.len)
        pointer.setPointer(8, value.data)
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0

    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}

// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): Int

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity.toLong()).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
            val item = read(byteBuf)
            if (byteBuf.hasRemaining()) {
                throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
            }
            return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
public interface FfiConverterRustBuffer<KotlinType> : FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}

// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
@Structure.FieldOrder("code", "error_buf")
internal open class RustCallStatus : Structure() {
    @JvmField var code: Int = 0

    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    fun isSuccess(): Boolean {
        return code == 0
    }

    fun isError(): Boolean {
        return code == 1
    }

    fun isPanic(): Boolean {
        return code == 2
    }
}

class InternalException(message: String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E : Exception> rustCallWithError(errorHandler: CallStatusErrorHandler<E>, callback: (RustCallStatus) -> U): U {
    var status = RustCallStatus()
    val return_value = callback(status)
    if (status.isSuccess()) {
        return return_value
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object NullCallStatusErrorHandler : CallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> rustCall(callback: (RustCallStatus) -> U): U {
    return rustCallWithError(NullCallStatusErrorHandler, callback)
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "uniffi_zcash"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String,
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface _UniFFILib : Library {
    companion object {
        internal val INSTANCE: _UniFFILib by lazy {
            loadIndirect<_UniFFILib>(componentName = "zcash")
        }
    }

    fun ffi_zcash_e53_ZcashRecipientAddress_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashRecipientAddress_decode(
        `params`: RustBuffer.ByValue,
        `address`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashRecipientAddress_shielded(
        `addr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashRecipientAddress_transparent(
        `addr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashRecipientAddress_unified(
        `addr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashRecipientAddress_encode(
        `ptr`: Pointer,
        `params`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashUnifiedAddress_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashUnifiedAddress_new(
        `orchard`: RustBuffer.ByValue,
        `sapling`: RustBuffer.ByValue,
        `transparent`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedAddress_decode(
        `params`: RustBuffer.ByValue,
        `address`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedAddress_orchard(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashUnifiedAddress_sapling(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashUnifiedAddress_transparent(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashUnifiedAddress_encode(
        `ptr`: Pointer,
        `params`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashUnifiedFullViewingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashUnifiedFullViewingKey_new(
        `transparent`: RustBuffer.ByValue,
        `sapling`: RustBuffer.ByValue,
        `orchard`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedFullViewingKey_decode(
        `params`: RustBuffer.ByValue,
        `encoded`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedFullViewingKey_encode(
        `ptr`: Pointer,
        `params`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashUnifiedFullViewingKey_transparent(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashUnifiedFullViewingKey_sapling(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashUnifiedFullViewingKey_orchard(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashUnifiedFullViewingKey_address(
        `ptr`: Pointer,
        `j`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashUnifiedFullViewingKey_find_address(
        `ptr`: Pointer,
        `j`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashUnifiedFullViewingKey_default_address(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashUnifiedSpendingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashUnifiedSpendingKey_from_seed(
        `params`: RustBuffer.ByValue,
        `seed`: RustBuffer.ByValue,
        `accountId`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedSpendingKey_from_bytes(
        `era`: RustBuffer.ByValue,
        `encoded`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedSpendingKey_to_unified_full_viewing_key(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedSpendingKey_transparent(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedSpendingKey_sapling(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedSpendingKey_orchard(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashUnifiedSpendingKey_to_bytes(
        `ptr`: Pointer,
        `era`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardNote_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardNote_from_parts(
        `recipient`: Pointer,
        `value`: Pointer,
        `rho`: Pointer,
        `rseed`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardNote_recipient(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardNote_value(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardNote_commitment(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashOrchardNullifier_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardNullifier_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardNullifier_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardRandomSeed_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardRandomSeed_from_bytes(
        `data`: RustBuffer.ByValue,
        `rho`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardRandomSeed_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardNoteCommitment_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardNoteCommitment_to_extracted_note_commitment(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashExtractedNoteCommitment_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashExtractedNoteCommitment_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtractedNoteCommitment_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardAddress_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardAddress_from_raw_address_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardAddress_diversifier(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardAddress_to_raw_address_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashVerifyingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashVerifyingKey_new(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashProvingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashProvingKey_new(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashOrchardBundle_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardBundle_actions(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardBundle_flags(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardBundle_value_balance(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardBundle_anchor(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardBundle_verify_proof(
        `ptr`: Pointer,
        `key`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardBundle_decrypt_output_with_key(
        `ptr`: Pointer,
        `actionIdx`: Long,
        `ivk`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardBundle_decrypt_output_with_keys(
        `ptr`: Pointer,
        `ivks`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardBundle_recover_output_with_ovk(
        `ptr`: Pointer,
        `actionIdx`: Long,
        `ovk`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardBundle_recover_outputs_with_ovks(
        `ptr`: Pointer,
        `ovks`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardFlags_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardFlags_from_parts(
        `spendsEnabled`: Byte,
        `outputsEnabled`: Byte,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardFlags_from_byte(
        `v`: Byte,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardFlags_spends_enabled(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun zcash_e53_ZcashOrchardFlags_outputs_enabled(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun zcash_e53_ZcashOrchardFlags_to_byte(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun ffi_zcash_e53_ZcashOrchardNoteValue_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardNoteValue_from_raw(
        `value`: Long,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardNoteValue_value(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Long

    fun ffi_zcash_e53_ZcashOrchardValueCommitment_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardValueCommitment_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardAction_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardAction_nullifier(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardAction_cmx(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardAction_encrypted_note(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardAction_cv_net(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashOrchardFullViewingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardFullViewingKey_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardFullViewingKey_address_at(
        `ptr`: Pointer,
        `j`: Pointer,
        `scope`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardFullViewingKey_address(
        `ptr`: Pointer,
        `d`: Pointer,
        `scope`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardFullViewingKey_scope_for_address(
        `ptr`: Pointer,
        `address`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardFullViewingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardFullViewingKey_to_ivk(
        `ptr`: Pointer,
        `scope`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardFullViewingKey_to_ovk(
        `ptr`: Pointer,
        `scope`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashOrchardSpendingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardSpendingKey_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardSpendingKey_from_zip32_seed(
        `seed`: RustBuffer.ByValue,
        `coinType`: Int,
        `account`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardSpendingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardSpendingKey_to_fvk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashAnchor_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashAnchor_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAnchor_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardIncomingViewingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardIncomingViewingKey_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardIncomingViewingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardIncomingViewingKey_diversifier_index(
        `ptr`: Pointer,
        `addr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashOrchardIncomingViewingKey_address_at(
        `ptr`: Pointer,
        `j`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardIncomingViewingKey_address(
        `ptr`: Pointer,
        `diversifier`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashOrchardDiversifier_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardDiversifier_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardDiversifier_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardOutgoingViewingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardOutgoingViewingKey_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardOutgoingViewingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardMerklePath_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardMerklePath_from_parts(
        `position`: Int,
        `authPath`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardMerklePath_root(
        `ptr`: Pointer,
        `cmx`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashOrchardMerkleHash_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardMerkleHash_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardMerkleHash_from_cmx(
        `cmx`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardMerkleHash_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardDiversifierIndex_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardDiversifierIndex_from_bytes(
        `b`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardDiversifierIndex_from_u32(
        `i`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardDiversifierIndex_from_u64(
        `i`: Long,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardDiversifierIndex_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashExtendedPrivKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashExtendedPrivKey_random(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedPrivKey_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedPrivKey_random_with_seed_size(
        `seedSize`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedPrivKey_with_seed(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedPrivKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExtendedPrivKey_derive_private_key(
        `ptr`: Pointer,
        `keyIndex`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashKeyIndex_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashKeyIndex_from_u32(
        `i`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashKeyIndex_hardened_from_normalize_index(
        `i`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashKeyIndex_from_index(
        `i`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashKeyIndex_raw_index(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Int

    fun zcash_e53_ZcashKeyIndex_normalize_index(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Int

    fun zcash_e53_ZcashKeyIndex_is_valid(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun ffi_zcash_e53_ZcashZip317FeeRule_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashZip317FeeRule_standard(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashZip317FeeRule_non_standard(
        `marginalFee`: Pointer,
        `graceActions`: Long,
        `p2pkhStandardInputSize`: Long,
        `p2pkhStandardOutputSize`: Long,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashZip317FeeRule_marginal_fee(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashFixedFeeRule_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashFixedFeeRule_non_standard(
        `fixedFee`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashFixedFeeRule_standard(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashFixedFeeRule_fixed_fee(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashTransparentBundle_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTransparentBundle_is_coinbase(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun zcash_e53_ZcashTransparentBundle_vin(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashTransparentBundle_vout(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashTxOut_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTxOut_new(
        `value`: Pointer,
        `scriptPubkey`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTxOut_value(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTxOut_script_pubkey(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTxOut_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashTxOut_recipient_address(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashTxIn_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTxIn_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashTransactionBuilder_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTransactionBuilder_new(
        `parameters`: RustBuffer.ByValue,
        `blockHeight`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTransactionBuilder_add_sapling_spend(
        `ptr`: Pointer,
        `extsk`: Pointer,
        `diversifier`: Pointer,
        `note`: Pointer,
        `merklePath`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTransactionBuilder_add_sapling_output(
        `ptr`: Pointer,
        `ovk`: RustBuffer.ByValue,
        `to`: Pointer,
        `value`: Pointer,
        `memo`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTransactionBuilder_add_transparent_input(
        `ptr`: Pointer,
        `sk`: Pointer,
        `utxo`: Pointer,
        `coin`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTransactionBuilder_add_transparent_output(
        `ptr`: Pointer,
        `to`: Pointer,
        `value`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTransactionBuilder_build(
        `ptr`: Pointer,
        `prover`: Pointer,
        `feeRule`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashTransaction_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTransaction_from_bytes(
        `data`: RustBuffer.ByValue,
        `consensusBranchId`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTransaction_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashTransaction_txid(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTransaction_version(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTransaction_consensus_branch_id(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashTransaction_lock_time(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Int

    fun zcash_e53_ZcashTransaction_expiry_height(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTransaction_transparent_bundle(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashTransaction_sapling_bundle(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashTransaction_orchard_bundle(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashTxId_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTxId_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTxId_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOrchardTransactionBuilder_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardTransactionBuilder_new(
        `parameters`: RustBuffer.ByValue,
        `targetHeight`: Pointer,
        `expiryHeight`: Pointer,
        `anchor`: Pointer,
        `flags`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOrchardTransactionBuilder_add_spend(
        `ptr`: Pointer,
        `fvk`: Pointer,
        `note`: Pointer,
        `merklePath`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardTransactionBuilder_add_recipient(
        `ptr`: Pointer,
        `ovk`: RustBuffer.ByValue,
        `recipient`: Pointer,
        `value`: Long,
        `memo`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOrchardTransactionBuilder_build(
        `ptr`: Pointer,
        `keys`: RustBuffer.ByValue,
        `sighash`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashTxVersion_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTxVersion_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTxVersion_suggested_for_branch(
        `consensusBranchId`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTxVersion_selection(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashTxVersion_header(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Int

    fun zcash_e53_ZcashTxVersion_version_group_id(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Int

    fun zcash_e53_ZcashTxVersion_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashTxVersion_has_sprout(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun zcash_e53_ZcashTxVersion_has_overwinter(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun zcash_e53_ZcashTxVersion_has_sapling(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun zcash_e53_ZcashTxVersion_has_orchard(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun ffi_zcash_e53_ZcashOutPoint_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOutPoint_new(
        `hash`: RustBuffer.ByValue,
        `n`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashAmount_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashAmount_new(
        `amount`: Long,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAmount_zero(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAmount_value(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Long

    fun ffi_zcash_e53_ZcashSaplingSpendDescription_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingSpendDescription_cv(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashSaplingSpendDescription_anchor(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashSaplingSpendDescription_nullifier(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashSaplingSpendDescription_rk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashSaplingBundle_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingBundle_shielded_spends(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashSaplingBundle_shielded_outputs(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashSaplingBundle_value_balance(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashSaplingOutputDescription_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingOutputDescription_cv(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashSaplingOutputDescription_cmu(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashSaplingMetadata_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingMetadata_new(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashSaplingMetadata_spend_index(
        `ptr`: Pointer,
        `n`: Long,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashSaplingMetadata_output_index(
        `ptr`: Pointer,
        `n`: Long,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashBlockHeight_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashBlockHeight_new(
        `v`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashBlockHeight_value(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Int

    fun ffi_zcash_e53_ZcashCommitmentTree_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashCommitmentTree_empty(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashCommitmentTree_append(
        `ptr`: Pointer,
        `node`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun ffi_zcash_e53_ZcashSaplingMerklePath_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingMerklePath_auth_path(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashSaplingMerklePath_position(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Long

    fun ffi_zcash_e53_ZcashIncrementalWitness_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashIncrementalWitness_from_tree(
        `tree`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashIncrementalWitness_append(
        `ptr`: Pointer,
        `node`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashIncrementalWitness_path(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashTransparentAddress_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashTransparentAddress_from_public_key(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTransparentAddress_from_script(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTransparentAddress_decode(
        `params`: RustBuffer.ByValue,
        `input`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTransparentAddress_encode(
        `ptr`: Pointer,
        `params`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashTransparentAddress_is_public_key(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun zcash_e53_ZcashTransparentAddress_is_script(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Byte

    fun zcash_e53_ZcashTransparentAddress_script(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashTransparentAddress_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashExternalIvk_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashExternalIvk_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExternalIvk_derive_address(
        `ptr`: Pointer,
        `childIndex`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExternalIvk_default_address(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExternalIvk_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashInternalIvk_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashInternalIvk_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashInternalIvk_default_address(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashInternalIvk_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashExternalOvk_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashExternalOvk_as_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashInternalOvk_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashInternalOvk_as_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashAccountPubKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashAccountPubKey_new(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPubKey_derive_external_ivk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPubKey_derive_internal_ivk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPubKey_ovks_for_shielding(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashAccountPubKey_internal_ovk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPubKey_external_ovk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPubKey_serialize(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashAccountPrivKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashAccountPrivKey_from_seed(
        `params`: RustBuffer.ByValue,
        `seed`: RustBuffer.ByValue,
        `accountId`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPrivKey_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPrivKey_from_extended_privkey(
        `key`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPrivKey_to_account_pubkey(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPrivKey_derive_external_secret_key(
        `ptr`: Pointer,
        `childIndex`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPrivKey_derive_internal_secret_key(
        `ptr`: Pointer,
        `childIndex`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashAccountPrivKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashScript_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashScript_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashScript_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashSaplingValueCommitment_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingValueCommitment_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashSaplingNote_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingNote_from_parts(
        `recipient`: Pointer,
        `value`: Pointer,
        `rseed`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashSaplingNote_value(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashSaplingNote_cmu(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashSaplingNoteValue_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingNoteValue_from_raw(
        `data`: Long,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashSaplingNoteValue_inner(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Long

    fun ffi_zcash_e53_ZcashSaplingNullifier_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingNullifier_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashSaplingExtractedNoteCommitment_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingExtractedNoteCommitment_new(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashSaplingExtractedNoteCommitment_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashPaymentAddress_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashPaymentAddress_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashPaymentAddress_decode(
        `params`: RustBuffer.ByValue,
        `input`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashPaymentAddress_encode(
        `ptr`: Pointer,
        `params`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashPaymentAddress_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashPaymentAddress_diversifier(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashPaymentAddress_pk_d(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashPaymentAddress_create_note(
        `ptr`: Pointer,
        `value`: Long,
        `rseed`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashSaplingIvk_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingIvk_to_payment_address(
        `ptr`: Pointer,
        `diversifier`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashSaplingIvk_to_repr(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashDiversifier_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashDiversifier_new(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashDiversifier_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashFullViewingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashFullViewingKey_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashFullViewingKey_from_expanded_spending_key(
        `expsk`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashFullViewingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashFullViewingKey_vk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashFullViewingKey_ovk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashNullifierDerivingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashNullifierDerivingKey_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashNullifierDerivingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashOutgoingViewingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashOutgoingViewingKey_from_bytes(
        `b`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashOutgoingViewingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashExpandedSpendingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashExpandedSpendingKey_from_spending_key(
        `sk`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExpandedSpendingKey_from_bytes(
        `b`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExpandedSpendingKey_proof_generation_key(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExpandedSpendingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashProofGenerationKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashProofGenerationKey_to_viewing_key(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashDiversifiableFullViewingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashDiversifiableFullViewingKey_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashDiversifiableFullViewingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashDiversifiableFullViewingKey_fvk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashDiversifiableFullViewingKey_to_nk(
        `ptr`: Pointer,
        `scope`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashDiversifiableFullViewingKey_to_ivk(
        `ptr`: Pointer,
        `scope`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashDiversifiableFullViewingKey_to_ovk(
        `ptr`: Pointer,
        `scope`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashDiversifiableFullViewingKey_address(
        `ptr`: Pointer,
        `j`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashDiversifiableFullViewingKey_find_address(
        `ptr`: Pointer,
        `j`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashDiversifiableFullViewingKey_default_address(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashDiversifiableFullViewingKey_diversified_address(
        `ptr`: Pointer,
        `diversifier`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashDiversifiableFullViewingKey_change_address(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashDiversifiableFullViewingKey_diversified_change_address(
        `ptr`: Pointer,
        `diversifier`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashDiversifiableFullViewingKey_decrypt_diversifier(
        `ptr`: Pointer,
        `addr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashSaplingDiversifiedTransmissionKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun ffi_zcash_e53_ZcashViewingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashViewingKey_ivk(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashViewingKey_to_payment_address(
        `ptr`: Pointer,
        `diversifier`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashExtendedFullViewingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashExtendedFullViewingKey_from_bytes(
        `bytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedFullViewingKey_decode(
        `params`: RustBuffer.ByValue,
        `input`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedFullViewingKey_encode(
        `ptr`: Pointer,
        `params`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExtendedFullViewingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExtendedFullViewingKey_address(
        `ptr`: Pointer,
        `j`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExtendedFullViewingKey_derive_child(
        `ptr`: Pointer,
        `i`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedFullViewingKey_find_address(
        `ptr`: Pointer,
        `j`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExtendedFullViewingKey_default_address(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExtendedFullViewingKey_derive_internal(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashSaplingPublicKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingPublicKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashSaplingNode_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashSaplingNode_from_cmu(
        `cmu`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashExtendedSpendingKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashExtendedSpendingKey_master(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedSpendingKey_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedSpendingKey_from_path(
        `master`: Pointer,
        `path`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedSpendingKey_decode(
        `params`: RustBuffer.ByValue,
        `input`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedSpendingKey_encode(
        `ptr`: Pointer,
        `params`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExtendedSpendingKey_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExtendedSpendingKey_derive_child(
        `ptr`: Pointer,
        `index`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedSpendingKey_default_address(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_ZcashExtendedSpendingKey_derive_internal(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_ZcashDiversifierIndex_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashDiversifierIndex_new(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashDiversifierIndex_from_u32(
        `i`: Int,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashDiversifierIndex_from_u64(
        `i`: Long,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashDiversifierIndex_increment(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashDiversifierIndex_to_u32(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Int

    fun zcash_e53_ZcashDiversifierIndex_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashMemoBytes_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashMemoBytes_new(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashMemoBytes_empty(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashMemoBytes_data(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashLocalTxProver_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashLocalTxProver_new(
        `spendPath`: RustBuffer.ByValue,
        `outputPath`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashLocalTxProver_from_bytes(
        `spendParamBytes`: RustBuffer.ByValue,
        `outputParamBytes`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashLocalTxProver_with_default_location(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun ffi_zcash_e53_SecpSecretKey_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_SecpSecretKey_new(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_SecpSecretKey_serialize_secret(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_ZcashJubjubFr_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_ZcashJubjubFr_from_bytes(
        `data`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_ZcashJubjubFr_to_bytes(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_TestSupport_object_free(
        `ptr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun zcash_e53_TestSupport_from_csv_file(
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_TestSupport_get_as_u8_array(
        `ptr`: Pointer,
        `key`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_TestSupport_get_as_u32_array(
        `ptr`: Pointer,
        `key`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_TestSupport_get_as_u64_array(
        `ptr`: Pointer,
        `key`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_TestSupport_get_as_u32(
        `ptr`: Pointer,
        `key`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Int

    fun zcash_e53_TestSupport_get_as_u64(
        `ptr`: Pointer,
        `key`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Long

    fun zcash_e53_TestSupport_get_as_string(
        `ptr`: Pointer,
        `key`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_decode_extended_full_viewing_key(
        `hrp`: RustBuffer.ByValue,
        `s`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_decode_extended_spending_key(
        `hrp`: RustBuffer.ByValue,
        `s`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_decode_payment_address(
        `hrp`: RustBuffer.ByValue,
        `s`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_decode_transparent_address(
        `pubkeyVersion`: RustBuffer.ByValue,
        `scriptVersion`: RustBuffer.ByValue,
        `s`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Pointer

    fun zcash_e53_encode_extended_full_viewing_key(
        `hrp`: RustBuffer.ByValue,
        `extfvk`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_encode_extended_spending_key(
        `hrp`: RustBuffer.ByValue,
        `extsk`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_encode_payment_address(
        `hrp`: RustBuffer.ByValue,
        `addr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_encode_payment_address_p(
        `params`: RustBuffer.ByValue,
        `addr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_encode_transparent_address(
        `pubkeyVersion`: RustBuffer.ByValue,
        `scriptVersion`: RustBuffer.ByValue,
        `addr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun zcash_e53_encode_transparent_address_p(
        `params`: RustBuffer.ByValue,
        `addr`: Pointer,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_rustbuffer_alloc(
        `size`: Int,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_rustbuffer_from_bytes(
        `bytes`: ForeignBytes.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_zcash_e53_rustbuffer_free(
        `buf`: RustBuffer.ByValue,
        _uniffi_out_err: RustCallStatus,
    ): Unit

    fun ffi_zcash_e53_rustbuffer_reserve(
        `buf`: RustBuffer.ByValue,
        `additional`: Int,
        _uniffi_out_err: RustCallStatus,
    ): RustBuffer.ByValue
}

// Public interface members begin here.

public object FfiConverterUByte : FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

public object FfiConverterUInt : FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

public object FfiConverterULong : FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

public object FfiConverterLong : FfiConverter<Long, Long> {
    override fun lift(value: Long): Long {
        return value
    }

    override fun read(buf: ByteBuffer): Long {
        return buf.getLong()
    }

    override fun lower(value: Long): Long {
        return value
    }

    override fun allocationSize(value: Long) = 8

    override fun write(value: Long, buf: ByteBuffer) {
        buf.putLong(value)
    }
}

public object FfiConverterBoolean : FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

public object FfiConverterString : FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len)
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteArr = value.toByteArray(Charsets.UTF_8)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteArr.size)
        rbuf.asByteBuffer()!!.put(byteArr)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    override fun allocationSize(value: String): Int {
        val sizeForLength = 4
        val sizeForString = value.length * 3
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteArr = value.toByteArray(Charsets.UTF_8)
        buf.putInt(byteArr.size)
        buf.put(byteArr)
    }
}

// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

// The base class for all UniFFI Object types.
//
// This class provides core operations for working with the Rust `Arc<T>` pointer to
// the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// the Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each `FFIObject` instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an `FFIObject` is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an `FFIObject` instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so will
//     leak the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each `FFIObject` an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// In the future we may be able to replace some of this with automatic finalization logic, such as using
// the new "Cleaner" functionaility in Java 9. The above scheme has been designed to work even if `destroy` is
// invoked by garbage-collection machinery rather than by calling code (which by the way, it's apparently also
// possible for the JVM to finalize an object while there is an in-flight call to one of its methods [1],
// so there would still be some complexity here).
//
// Sigh...all of this for want of a robust finalization mechanism.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//
abstract class FFIObject(
    protected val pointer: Pointer,
) : Disposable, AutoCloseable {

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    protected open fun freeRustArcPtr() {
        // To be overridden in subclasses.
    }

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                this.freeRustArcPtr()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.pointer)
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                this.freeRustArcPtr()
            }
        }
    }
}

public interface SecpSecretKeyInterface {

    fun `serializeSecret`(): List<UByte>
}

class SecpSecretKey(
    pointer: Pointer,
) : FFIObject(pointer), SecpSecretKeyInterface {

    constructor(`data`: List<UByte>) :
        this(
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_SecpSecretKey_new(FfiConverterSequenceUByte.lower(`data`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_SecpSecretKey_object_free(this.pointer, status)
        }
    }

    override fun `serializeSecret`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_SecpSecretKey_serialize_secret(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeSecpSecretKey : FfiConverter<SecpSecretKey, Pointer> {
    override fun lower(value: SecpSecretKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): SecpSecretKey {
        return SecpSecretKey(value)
    }

    override fun read(buf: ByteBuffer): SecpSecretKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SecpSecretKey) = 8

    override fun write(value: SecpSecretKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface TestSupportInterface {

    fun `getAsU8Array`(`key`: String): List<UByte>

    fun `getAsU32Array`(`key`: String): List<UInt>

    fun `getAsU64Array`(`key`: String): List<ULong>

    fun `getAsU32`(`key`: String): UInt

    fun `getAsU64`(`key`: String): ULong

    fun `getAsString`(`key`: String): String
}

class TestSupport(
    pointer: Pointer,
) : FFIObject(pointer), TestSupportInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_TestSupport_object_free(this.pointer, status)
        }
    }

    override fun `getAsU8Array`(`key`: String): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_TestSupport_get_as_u8_array(it, FfiConverterString.lower(`key`), _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `getAsU32Array`(`key`: String): List<UInt> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_TestSupport_get_as_u32_array(it, FfiConverterString.lower(`key`), _status)
            }
        }.let {
            FfiConverterSequenceUInt.lift(it)
        }
    override fun `getAsU64Array`(`key`: String): List<ULong> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_TestSupport_get_as_u64_array(it, FfiConverterString.lower(`key`), _status)
            }
        }.let {
            FfiConverterSequenceULong.lift(it)
        }
    override fun `getAsU32`(`key`: String): UInt =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_TestSupport_get_as_u32(it, FfiConverterString.lower(`key`), _status)
            }
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `getAsU64`(`key`: String): ULong =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_TestSupport_get_as_u64(it, FfiConverterString.lower(`key`), _status)
            }
        }.let {
            FfiConverterULong.lift(it)
        }
    override fun `getAsString`(`key`: String): String =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_TestSupport_get_as_string(it, FfiConverterString.lower(`key`), _status)
            }
        }.let {
            FfiConverterString.lift(it)
        }

    companion object {

        fun `fromCsvFile`(): TestSupport =
            TestSupport(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_TestSupport_from_csv_file(_status)
                },
            )
    }
}

public object FfiConverterTypeTestSupport : FfiConverter<TestSupport, Pointer> {
    override fun lower(value: TestSupport): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): TestSupport {
        return TestSupport(value)
    }

    override fun read(buf: ByteBuffer): TestSupport {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: TestSupport) = 8

    override fun write(value: TestSupport, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashAccountPrivKeyInterface {

    fun `toAccountPubkey`(): ZcashAccountPubKey

    @Throws(ZcashException::class)
    fun `deriveExternalSecretKey`(`childIndex`: UInt): SecpSecretKey

    @Throws(ZcashException::class)
    fun `deriveInternalSecretKey`(`childIndex`: UInt): SecpSecretKey

    fun `toBytes`(): List<UByte>
}

class ZcashAccountPrivKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashAccountPrivKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashAccountPrivKey_object_free(this.pointer, status)
        }
    }

    override fun `toAccountPubkey`(): ZcashAccountPubKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPrivKey_to_account_pubkey(it, _status)
            }
        }.let {
            FfiConverterTypeZcashAccountPubKey.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `deriveExternalSecretKey`(`childIndex`: UInt): SecpSecretKey =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPrivKey_derive_external_secret_key(it, FfiConverterUInt.lower(`childIndex`), _status)
            }
        }.let {
            FfiConverterTypeSecpSecretKey.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `deriveInternalSecretKey`(`childIndex`: UInt): SecpSecretKey =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPrivKey_derive_internal_secret_key(it, FfiConverterUInt.lower(`childIndex`), _status)
            }
        }.let {
            FfiConverterTypeSecpSecretKey.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPrivKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromSeed`(`params`: ZcashConsensusParameters, `seed`: List<UByte>, `accountId`: ZcashAccountId): ZcashAccountPrivKey =
            ZcashAccountPrivKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPrivKey_from_seed(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterSequenceUByte.lower(`seed`), FfiConverterTypeZcashAccountId.lower(`accountId`), _status)
                },
            )

        fun `fromBytes`(`data`: List<UByte>): ZcashAccountPrivKey =
            ZcashAccountPrivKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPrivKey_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )

        fun `fromExtendedPrivkey`(`key`: ZcashExtendedPrivKey): ZcashAccountPrivKey =
            ZcashAccountPrivKey(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPrivKey_from_extended_privkey(FfiConverterTypeZcashExtendedPrivKey.lower(`key`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashAccountPrivKey : FfiConverter<ZcashAccountPrivKey, Pointer> {
    override fun lower(value: ZcashAccountPrivKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashAccountPrivKey {
        return ZcashAccountPrivKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashAccountPrivKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashAccountPrivKey) = 8

    override fun write(value: ZcashAccountPrivKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashAccountPubKeyInterface {

    @Throws(ZcashException::class)
    fun `deriveExternalIvk`(): ZcashExternalIvk

    @Throws(ZcashException::class)
    fun `deriveInternalIvk`(): ZcashInternalIvk

    fun `ovksForShielding`(): ZcashInternalOvkExternalOvk

    fun `internalOvk`(): ZcashInternalOvk

    fun `externalOvk`(): ZcashExternalOvk

    fun `serialize`(): List<UByte>
}

class ZcashAccountPubKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashAccountPubKeyInterface {

    constructor(`data`: List<UByte>) :
        this(
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPubKey_new(FfiConverterSequenceUByte.lower(`data`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashAccountPubKey_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `deriveExternalIvk`(): ZcashExternalIvk =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPubKey_derive_external_ivk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashExternalIvk.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `deriveInternalIvk`(): ZcashInternalIvk =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPubKey_derive_internal_ivk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashInternalIvk.lift(it)
        }
    override fun `ovksForShielding`(): ZcashInternalOvkExternalOvk =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPubKey_ovks_for_shielding(it, _status)
            }
        }.let {
            FfiConverterTypeZcashInternalOvkExternalOvk.lift(it)
        }
    override fun `internalOvk`(): ZcashInternalOvk =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPubKey_internal_ovk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashInternalOvk.lift(it)
        }
    override fun `externalOvk`(): ZcashExternalOvk =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPubKey_external_ovk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashExternalOvk.lift(it)
        }
    override fun `serialize`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAccountPubKey_serialize(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashAccountPubKey : FfiConverter<ZcashAccountPubKey, Pointer> {
    override fun lower(value: ZcashAccountPubKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashAccountPubKey {
        return ZcashAccountPubKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashAccountPubKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashAccountPubKey) = 8

    override fun write(value: ZcashAccountPubKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashAmountInterface {

    fun `value`(): Long
}

class ZcashAmount(
    pointer: Pointer,
) : FFIObject(pointer), ZcashAmountInterface {

    constructor(`amount`: Long) :
        this(
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAmount_new(FfiConverterLong.lower(`amount`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashAmount_object_free(this.pointer, status)
        }
    }

    override fun `value`(): Long =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAmount_value(it, _status)
            }
        }.let {
            FfiConverterLong.lift(it)
        }

    companion object {

        fun `zero`(): ZcashAmount =
            ZcashAmount(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashAmount_zero(_status)
                },
            )
    }
}

public object FfiConverterTypeZcashAmount : FfiConverter<ZcashAmount, Pointer> {
    override fun lower(value: ZcashAmount): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashAmount {
        return ZcashAmount(value)
    }

    override fun read(buf: ByteBuffer): ZcashAmount {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashAmount) = 8

    override fun write(value: ZcashAmount, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashAnchorInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashAnchor(
    pointer: Pointer,
) : FFIObject(pointer), ZcashAnchorInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashAnchor_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashAnchor_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashAnchor =
            ZcashAnchor(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashAnchor_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashAnchor : FfiConverter<ZcashAnchor, Pointer> {
    override fun lower(value: ZcashAnchor): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashAnchor {
        return ZcashAnchor(value)
    }

    override fun read(buf: ByteBuffer): ZcashAnchor {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashAnchor) = 8

    override fun write(value: ZcashAnchor, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashBlockHeightInterface {

    fun `value`(): UInt
}

class ZcashBlockHeight(
    pointer: Pointer,
) : FFIObject(pointer), ZcashBlockHeightInterface {

    constructor(`v`: UInt) :
        this(
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashBlockHeight_new(FfiConverterUInt.lower(`v`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashBlockHeight_object_free(this.pointer, status)
        }
    }

    override fun `value`(): UInt =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashBlockHeight_value(it, _status)
            }
        }.let {
            FfiConverterUInt.lift(it)
        }
}

public object FfiConverterTypeZcashBlockHeight : FfiConverter<ZcashBlockHeight, Pointer> {
    override fun lower(value: ZcashBlockHeight): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashBlockHeight {
        return ZcashBlockHeight(value)
    }

    override fun read(buf: ByteBuffer): ZcashBlockHeight {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashBlockHeight) = 8

    override fun write(value: ZcashBlockHeight, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashCommitmentTreeInterface {

    @Throws(ZcashException::class)
    fun `append`(`node`: ZcashSaplingNode)
}

class ZcashCommitmentTree(
    pointer: Pointer,
) : FFIObject(pointer), ZcashCommitmentTreeInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashCommitmentTree_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `append`(`node`: ZcashSaplingNode) =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashCommitmentTree_append(it, FfiConverterTypeZcashSaplingNode.lower(`node`), _status)
            }
        }

    companion object {

        fun `empty`(): ZcashCommitmentTree =
            ZcashCommitmentTree(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashCommitmentTree_empty(_status)
                },
            )
    }
}

public object FfiConverterTypeZcashCommitmentTree : FfiConverter<ZcashCommitmentTree, Pointer> {
    override fun lower(value: ZcashCommitmentTree): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashCommitmentTree {
        return ZcashCommitmentTree(value)
    }

    override fun read(buf: ByteBuffer): ZcashCommitmentTree {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashCommitmentTree) = 8

    override fun write(value: ZcashCommitmentTree, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashDiversifiableFullViewingKeyInterface {

    fun `toBytes`(): List<UByte>

    fun `fvk`(): ZcashFullViewingKey

    fun `toNk`(`scope`: ZcashScope): ZcashNullifierDerivingKey

    fun `toIvk`(`scope`: ZcashScope): ZcashSaplingIvk

    fun `toOvk`(`scope`: ZcashScope): ZcashOutgoingViewingKey

    fun `address`(`j`: ZcashDiversifierIndex): ZcashPaymentAddress?

    fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashDiversifierIndexAndPaymentAddress?

    fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress

    fun `diversifiedAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress?

    fun `changeAddress`(): ZcashDiversifierIndexAndPaymentAddress

    fun `diversifiedChangeAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress?

    fun `decryptDiversifier`(`addr`: ZcashPaymentAddress): ZcashDiversifierIndexAndScope?
}

class ZcashDiversifiableFullViewingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashDiversifiableFullViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashDiversifiableFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `fvk`(): ZcashFullViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_fvk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashFullViewingKey.lift(it)
        }
    override fun `toNk`(`scope`: ZcashScope): ZcashNullifierDerivingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_to_nk(it, FfiConverterTypeZcashScope.lower(`scope`), _status)
            }
        }.let {
            FfiConverterTypeZcashNullifierDerivingKey.lift(it)
        }
    override fun `toIvk`(`scope`: ZcashScope): ZcashSaplingIvk =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_to_ivk(it, FfiConverterTypeZcashScope.lower(`scope`), _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingIvk.lift(it)
        }
    override fun `toOvk`(`scope`: ZcashScope): ZcashOutgoingViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_to_ovk(it, FfiConverterTypeZcashScope.lower(`scope`), _status)
            }
        }.let {
            FfiConverterTypeZcashOutgoingViewingKey.lift(it)
        }
    override fun `address`(`j`: ZcashDiversifierIndex): ZcashPaymentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashDiversifierIndexAndPaymentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_find_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_default_address(it, _status)
            }
        }.let {
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `diversifiedAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_diversified_address(it, FfiConverterTypeZcashDiversifier.lower(`diversifier`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `changeAddress`(): ZcashDiversifierIndexAndPaymentAddress =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_change_address(it, _status)
            }
        }.let {
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `diversifiedChangeAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_diversified_change_address(it, FfiConverterTypeZcashDiversifier.lower(`diversifier`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `decryptDiversifier`(`addr`: ZcashPaymentAddress): ZcashDiversifierIndexAndScope? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_decrypt_diversifier(it, FfiConverterTypeZcashPaymentAddress.lower(`addr`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashDiversifierIndexAndScope.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashDiversifiableFullViewingKey =
            ZcashDiversifiableFullViewingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifiableFullViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashDiversifiableFullViewingKey : FfiConverter<ZcashDiversifiableFullViewingKey, Pointer> {
    override fun lower(value: ZcashDiversifiableFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashDiversifiableFullViewingKey {
        return ZcashDiversifiableFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashDiversifiableFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashDiversifiableFullViewingKey) = 8

    override fun write(value: ZcashDiversifiableFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashDiversifierInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashDiversifier(
    pointer: Pointer,
) : FFIObject(pointer), ZcashDiversifierInterface {

    constructor(`bytes`: List<UByte>) :
        this(
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifier_new(FfiConverterSequenceUByte.lower(`bytes`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashDiversifier_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifier_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashDiversifier : FfiConverter<ZcashDiversifier, Pointer> {
    override fun lower(value: ZcashDiversifier): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashDiversifier {
        return ZcashDiversifier(value)
    }

    override fun read(buf: ByteBuffer): ZcashDiversifier {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashDiversifier) = 8

    override fun write(value: ZcashDiversifier, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashDiversifierIndexInterface {

    @Throws(ZcashException::class)
    fun `increment`()

    @Throws(ZcashException::class)
    fun `toU32`(): UInt

    fun `toBytes`(): List<UByte>
}

class ZcashDiversifierIndex(
    pointer: Pointer,
) : FFIObject(pointer), ZcashDiversifierIndexInterface {

    constructor() :
        this(
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifierIndex_new(_status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashDiversifierIndex_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `increment`() =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifierIndex_increment(it, _status)
            }
        }

    @Throws(ZcashException::class)
    override fun `toU32`(): UInt =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifierIndex_to_u32(it, _status)
            }
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifierIndex_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromU32`(`i`: UInt): ZcashDiversifierIndex =
            ZcashDiversifierIndex(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifierIndex_from_u32(FfiConverterUInt.lower(`i`), _status)
                },
            )

        fun `fromU64`(`i`: ULong): ZcashDiversifierIndex =
            ZcashDiversifierIndex(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashDiversifierIndex_from_u64(FfiConverterULong.lower(`i`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashDiversifierIndex : FfiConverter<ZcashDiversifierIndex, Pointer> {
    override fun lower(value: ZcashDiversifierIndex): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashDiversifierIndex {
        return ZcashDiversifierIndex(value)
    }

    override fun read(buf: ByteBuffer): ZcashDiversifierIndex {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashDiversifierIndex) = 8

    override fun write(value: ZcashDiversifierIndex, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashExpandedSpendingKeyInterface {

    fun `proofGenerationKey`(): ZcashProofGenerationKey

    fun `toBytes`(): List<UByte>
}

class ZcashExpandedSpendingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashExpandedSpendingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashExpandedSpendingKey_object_free(this.pointer, status)
        }
    }

    override fun `proofGenerationKey`(): ZcashProofGenerationKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExpandedSpendingKey_proof_generation_key(it, _status)
            }
        }.let {
            FfiConverterTypeZcashProofGenerationKey.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExpandedSpendingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromSpendingKey`(`sk`: List<UByte>): ZcashExpandedSpendingKey =
            ZcashExpandedSpendingKey(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExpandedSpendingKey_from_spending_key(FfiConverterSequenceUByte.lower(`sk`), _status)
                },
            )

        fun `fromBytes`(`b`: List<UByte>): ZcashExpandedSpendingKey =
            ZcashExpandedSpendingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExpandedSpendingKey_from_bytes(FfiConverterSequenceUByte.lower(`b`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashExpandedSpendingKey : FfiConverter<ZcashExpandedSpendingKey, Pointer> {
    override fun lower(value: ZcashExpandedSpendingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExpandedSpendingKey {
        return ZcashExpandedSpendingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashExpandedSpendingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExpandedSpendingKey) = 8

    override fun write(value: ZcashExpandedSpendingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashExtendedFullViewingKeyInterface {

    fun `encode`(`params`: ZcashConsensusParameters): String

    fun `toBytes`(): List<UByte>

    fun `address`(`j`: ZcashDiversifierIndex): ZcashPaymentAddress?

    @Throws(ZcashException::class)
    fun `deriveChild`(`i`: ZcashChildIndex): ZcashExtendedFullViewingKey

    fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashDiversifierIndexAndPaymentAddress?

    fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress

    fun `deriveInternal`(): ZcashExtendedFullViewingKey

    fun `toDiversifiableFullViewingKey`(): ZcashDiversifiableFullViewingKey
}

class ZcashExtendedFullViewingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashExtendedFullViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashExtendedFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`), _status)
            }
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `address`(`j`: ZcashDiversifierIndex): ZcashPaymentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `deriveChild`(`i`: ZcashChildIndex): ZcashExtendedFullViewingKey =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_derive_child(it, FfiConverterTypeZcashChildIndex.lower(`i`), _status)
            }
        }.let {
            FfiConverterTypeZcashExtendedFullViewingKey.lift(it)
        }
    override fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashDiversifierIndexAndPaymentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_find_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_default_address(it, _status)
            }
        }.let {
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `deriveInternal`(): ZcashExtendedFullViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_derive_internal(it, _status)
            }
        }.let {
            FfiConverterTypeZcashExtendedFullViewingKey.lift(it)
        }
    override fun `toDiversifiableFullViewingKey`(): ZcashDiversifiableFullViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key(it, _status)
            }
        }.let {
            FfiConverterTypeZcashDiversifiableFullViewingKey.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashExtendedFullViewingKey =
            ZcashExtendedFullViewingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )

        fun `decode`(`params`: ZcashConsensusParameters, `input`: String): ZcashExtendedFullViewingKey =
            ZcashExtendedFullViewingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedFullViewingKey_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`input`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashExtendedFullViewingKey : FfiConverter<ZcashExtendedFullViewingKey, Pointer> {
    override fun lower(value: ZcashExtendedFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExtendedFullViewingKey {
        return ZcashExtendedFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashExtendedFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExtendedFullViewingKey) = 8

    override fun write(value: ZcashExtendedFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashExtendedPrivKeyInterface {

    fun `toBytes`(): List<UByte>

    @Throws(ZcashException::class)
    fun `derivePrivateKey`(`keyIndex`: ZcashKeyIndex): ZcashExtendedPrivKey
}

class ZcashExtendedPrivKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashExtendedPrivKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashExtendedPrivKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedPrivKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `derivePrivateKey`(`keyIndex`: ZcashKeyIndex): ZcashExtendedPrivKey =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedPrivKey_derive_private_key(it, FfiConverterTypeZcashKeyIndex.lower(`keyIndex`), _status)
            }
        }.let {
            FfiConverterTypeZcashExtendedPrivKey.lift(it)
        }

    companion object {

        fun `random`(): ZcashExtendedPrivKey =
            ZcashExtendedPrivKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedPrivKey_random(_status)
                },
            )

        fun `fromBytes`(`bytes`: List<UByte>): ZcashExtendedPrivKey =
            ZcashExtendedPrivKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedPrivKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )

        fun `randomWithSeedSize`(`seedSize`: ZcashKeySeed): ZcashExtendedPrivKey =
            ZcashExtendedPrivKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedPrivKey_random_with_seed_size(FfiConverterTypeZcashKeySeed.lower(`seedSize`), _status)
                },
            )

        fun `withSeed`(`data`: List<UByte>): ZcashExtendedPrivKey =
            ZcashExtendedPrivKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedPrivKey_with_seed(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashExtendedPrivKey : FfiConverter<ZcashExtendedPrivKey, Pointer> {
    override fun lower(value: ZcashExtendedPrivKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExtendedPrivKey {
        return ZcashExtendedPrivKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashExtendedPrivKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExtendedPrivKey) = 8

    override fun write(value: ZcashExtendedPrivKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashExtendedSpendingKeyInterface {

    fun `encode`(`params`: ZcashConsensusParameters): String

    fun `toBytes`(): List<UByte>

    fun `deriveChild`(`index`: ZcashChildIndex): ZcashExtendedSpendingKey

    fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress

    fun `deriveInternal`(): ZcashExtendedSpendingKey

    fun `toDiversifiableFullViewingKey`(): ZcashDiversifiableFullViewingKey
}

class ZcashExtendedSpendingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashExtendedSpendingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashExtendedSpendingKey_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`), _status)
            }
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `deriveChild`(`index`: ZcashChildIndex): ZcashExtendedSpendingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_derive_child(it, FfiConverterTypeZcashChildIndex.lower(`index`), _status)
            }
        }.let {
            FfiConverterTypeZcashExtendedSpendingKey.lift(it)
        }
    override fun `defaultAddress`(): ZcashDiversifierIndexAndPaymentAddress =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_default_address(it, _status)
            }
        }.let {
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.lift(it)
        }
    override fun `deriveInternal`(): ZcashExtendedSpendingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_derive_internal(it, _status)
            }
        }.let {
            FfiConverterTypeZcashExtendedSpendingKey.lift(it)
        }
    override fun `toDiversifiableFullViewingKey`(): ZcashDiversifiableFullViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key(it, _status)
            }
        }.let {
            FfiConverterTypeZcashDiversifiableFullViewingKey.lift(it)
        }

    companion object {

        fun `master`(`data`: List<UByte>): ZcashExtendedSpendingKey =
            ZcashExtendedSpendingKey(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_master(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )

        fun `fromBytes`(`data`: List<UByte>): ZcashExtendedSpendingKey =
            ZcashExtendedSpendingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )

        fun `fromPath`(`master`: ZcashExtendedSpendingKey, `path`: List<ZcashChildIndex>): ZcashExtendedSpendingKey =
            ZcashExtendedSpendingKey(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_from_path(FfiConverterTypeZcashExtendedSpendingKey.lower(`master`), FfiConverterSequenceTypeZcashChildIndex.lower(`path`), _status)
                },
            )

        fun `decode`(`params`: ZcashConsensusParameters, `input`: String): ZcashExtendedSpendingKey =
            ZcashExtendedSpendingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtendedSpendingKey_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`input`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashExtendedSpendingKey : FfiConverter<ZcashExtendedSpendingKey, Pointer> {
    override fun lower(value: ZcashExtendedSpendingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExtendedSpendingKey {
        return ZcashExtendedSpendingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashExtendedSpendingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExtendedSpendingKey) = 8

    override fun write(value: ZcashExtendedSpendingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashExternalIvkInterface {

    @Throws(ZcashException::class)
    fun `deriveAddress`(`childIndex`: UInt): ZcashTransparentAddress

    fun `defaultAddress`(): ZcashTransparentAddressAndIndex

    fun `toBytes`(): List<UByte>
}

class ZcashExternalIvk(
    pointer: Pointer,
) : FFIObject(pointer), ZcashExternalIvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashExternalIvk_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `deriveAddress`(`childIndex`: UInt): ZcashTransparentAddress =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExternalIvk_derive_address(it, FfiConverterUInt.lower(`childIndex`), _status)
            }
        }.let {
            FfiConverterTypeZcashTransparentAddress.lift(it)
        }
    override fun `defaultAddress`(): ZcashTransparentAddressAndIndex =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExternalIvk_default_address(it, _status)
            }
        }.let {
            FfiConverterTypeZcashTransparentAddressAndIndex.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExternalIvk_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashExternalIvk =
            ZcashExternalIvk(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExternalIvk_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashExternalIvk : FfiConverter<ZcashExternalIvk, Pointer> {
    override fun lower(value: ZcashExternalIvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExternalIvk {
        return ZcashExternalIvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashExternalIvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExternalIvk) = 8

    override fun write(value: ZcashExternalIvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashExternalOvkInterface {

    fun `asBytes`(): List<UByte>
}

class ZcashExternalOvk(
    pointer: Pointer,
) : FFIObject(pointer), ZcashExternalOvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashExternalOvk_object_free(this.pointer, status)
        }
    }

    override fun `asBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExternalOvk_as_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashExternalOvk : FfiConverter<ZcashExternalOvk, Pointer> {
    override fun lower(value: ZcashExternalOvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExternalOvk {
        return ZcashExternalOvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashExternalOvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExternalOvk) = 8

    override fun write(value: ZcashExternalOvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashExtractedNoteCommitmentInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashExtractedNoteCommitment(
    pointer: Pointer,
) : FFIObject(pointer), ZcashExtractedNoteCommitmentInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashExtractedNoteCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashExtractedNoteCommitment_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashExtractedNoteCommitment =
            ZcashExtractedNoteCommitment(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashExtractedNoteCommitment_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashExtractedNoteCommitment : FfiConverter<ZcashExtractedNoteCommitment, Pointer> {
    override fun lower(value: ZcashExtractedNoteCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashExtractedNoteCommitment {
        return ZcashExtractedNoteCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashExtractedNoteCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashExtractedNoteCommitment) = 8

    override fun write(value: ZcashExtractedNoteCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashFixedFeeRuleInterface {

    fun `fixedFee`(): ZcashAmount
}

class ZcashFixedFeeRule(
    pointer: Pointer,
) : FFIObject(pointer), ZcashFixedFeeRuleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashFixedFeeRule_object_free(this.pointer, status)
        }
    }

    override fun `fixedFee`(): ZcashAmount =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashFixedFeeRule_fixed_fee(it, _status)
            }
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }

    companion object {

        fun `nonStandard`(`fixedFee`: ZcashAmount): ZcashFixedFeeRule =
            ZcashFixedFeeRule(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashFixedFeeRule_non_standard(FfiConverterTypeZcashAmount.lower(`fixedFee`), _status)
                },
            )

        fun `standard`(): ZcashFixedFeeRule =
            ZcashFixedFeeRule(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashFixedFeeRule_standard(_status)
                },
            )
    }
}

public object FfiConverterTypeZcashFixedFeeRule : FfiConverter<ZcashFixedFeeRule, Pointer> {
    override fun lower(value: ZcashFixedFeeRule): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashFixedFeeRule {
        return ZcashFixedFeeRule(value)
    }

    override fun read(buf: ByteBuffer): ZcashFixedFeeRule {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashFixedFeeRule) = 8

    override fun write(value: ZcashFixedFeeRule, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashFullViewingKeyInterface {

    fun `toBytes`(): List<UByte>

    fun `vk`(): ZcashViewingKey

    fun `ovk`(): ZcashOutgoingViewingKey
}

class ZcashFullViewingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashFullViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashFullViewingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `vk`(): ZcashViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashFullViewingKey_vk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashViewingKey.lift(it)
        }
    override fun `ovk`(): ZcashOutgoingViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashFullViewingKey_ovk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOutgoingViewingKey.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashFullViewingKey =
            ZcashFullViewingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashFullViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )

        fun `fromExpandedSpendingKey`(`expsk`: ZcashExpandedSpendingKey): ZcashFullViewingKey =
            ZcashFullViewingKey(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashFullViewingKey_from_expanded_spending_key(FfiConverterTypeZcashExpandedSpendingKey.lower(`expsk`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashFullViewingKey : FfiConverter<ZcashFullViewingKey, Pointer> {
    override fun lower(value: ZcashFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashFullViewingKey {
        return ZcashFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashFullViewingKey) = 8

    override fun write(value: ZcashFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashIncrementalWitnessInterface {

    @Throws(ZcashException::class)
    fun `append`(`node`: ZcashSaplingNode)

    fun `path`(): ZcashSaplingMerklePath?
}

class ZcashIncrementalWitness(
    pointer: Pointer,
) : FFIObject(pointer), ZcashIncrementalWitnessInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashIncrementalWitness_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `append`(`node`: ZcashSaplingNode) =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashIncrementalWitness_append(it, FfiConverterTypeZcashSaplingNode.lower(`node`), _status)
            }
        }

    override fun `path`(): ZcashSaplingMerklePath? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashIncrementalWitness_path(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashSaplingMerklePath.lift(it)
        }

    companion object {

        fun `fromTree`(`tree`: ZcashCommitmentTree): ZcashIncrementalWitness =
            ZcashIncrementalWitness(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashIncrementalWitness_from_tree(FfiConverterTypeZcashCommitmentTree.lower(`tree`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashIncrementalWitness : FfiConverter<ZcashIncrementalWitness, Pointer> {
    override fun lower(value: ZcashIncrementalWitness): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashIncrementalWitness {
        return ZcashIncrementalWitness(value)
    }

    override fun read(buf: ByteBuffer): ZcashIncrementalWitness {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashIncrementalWitness) = 8

    override fun write(value: ZcashIncrementalWitness, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashInternalIvkInterface {

    fun `defaultAddress`(): ZcashTransparentAddressAndIndex

    fun `toBytes`(): List<UByte>
}

class ZcashInternalIvk(
    pointer: Pointer,
) : FFIObject(pointer), ZcashInternalIvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashInternalIvk_object_free(this.pointer, status)
        }
    }

    override fun `defaultAddress`(): ZcashTransparentAddressAndIndex =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashInternalIvk_default_address(it, _status)
            }
        }.let {
            FfiConverterTypeZcashTransparentAddressAndIndex.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashInternalIvk_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashInternalIvk =
            ZcashInternalIvk(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashInternalIvk_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashInternalIvk : FfiConverter<ZcashInternalIvk, Pointer> {
    override fun lower(value: ZcashInternalIvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashInternalIvk {
        return ZcashInternalIvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashInternalIvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashInternalIvk) = 8

    override fun write(value: ZcashInternalIvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashInternalOvkInterface {

    fun `asBytes`(): List<UByte>
}

class ZcashInternalOvk(
    pointer: Pointer,
) : FFIObject(pointer), ZcashInternalOvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashInternalOvk_object_free(this.pointer, status)
        }
    }

    override fun `asBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashInternalOvk_as_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashInternalOvk : FfiConverter<ZcashInternalOvk, Pointer> {
    override fun lower(value: ZcashInternalOvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashInternalOvk {
        return ZcashInternalOvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashInternalOvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashInternalOvk) = 8

    override fun write(value: ZcashInternalOvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashJubjubFrInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashJubjubFr(
    pointer: Pointer,
) : FFIObject(pointer), ZcashJubjubFrInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashJubjubFr_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashJubjubFr_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashJubjubFr =
            ZcashJubjubFr(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashJubjubFr_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashJubjubFr : FfiConverter<ZcashJubjubFr, Pointer> {
    override fun lower(value: ZcashJubjubFr): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashJubjubFr {
        return ZcashJubjubFr(value)
    }

    override fun read(buf: ByteBuffer): ZcashJubjubFr {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashJubjubFr) = 8

    override fun write(value: ZcashJubjubFr, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashKeyIndexInterface {

    fun `rawIndex`(): UInt

    fun `normalizeIndex`(): UInt

    fun `isValid`(): Boolean
}

class ZcashKeyIndex(
    pointer: Pointer,
) : FFIObject(pointer), ZcashKeyIndexInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashKeyIndex_object_free(this.pointer, status)
        }
    }

    override fun `rawIndex`(): UInt =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashKeyIndex_raw_index(it, _status)
            }
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `normalizeIndex`(): UInt =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashKeyIndex_normalize_index(it, _status)
            }
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `isValid`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashKeyIndex_is_valid(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }

    companion object {

        fun `fromU32`(`i`: UInt): ZcashKeyIndex =
            ZcashKeyIndex(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashKeyIndex_from_u32(FfiConverterUInt.lower(`i`), _status)
                },
            )

        fun `hardenedFromNormalizeIndex`(`i`: UInt): ZcashKeyIndex =
            ZcashKeyIndex(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashKeyIndex_hardened_from_normalize_index(FfiConverterUInt.lower(`i`), _status)
                },
            )

        fun `fromIndex`(`i`: UInt): ZcashKeyIndex =
            ZcashKeyIndex(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashKeyIndex_from_index(FfiConverterUInt.lower(`i`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashKeyIndex : FfiConverter<ZcashKeyIndex, Pointer> {
    override fun lower(value: ZcashKeyIndex): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashKeyIndex {
        return ZcashKeyIndex(value)
    }

    override fun read(buf: ByteBuffer): ZcashKeyIndex {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashKeyIndex) = 8

    override fun write(value: ZcashKeyIndex, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashLocalTxProverInterface

class ZcashLocalTxProver(
    pointer: Pointer,
) : FFIObject(pointer), ZcashLocalTxProverInterface {

    constructor(`spendPath`: String, `outputPath`: String) :
        this(
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashLocalTxProver_new(FfiConverterString.lower(`spendPath`), FfiConverterString.lower(`outputPath`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashLocalTxProver_object_free(this.pointer, status)
        }
    }

    companion object {

        fun `fromBytes`(`spendParamBytes`: List<UByte>, `outputParamBytes`: List<UByte>): ZcashLocalTxProver =
            ZcashLocalTxProver(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashLocalTxProver_from_bytes(FfiConverterSequenceUByte.lower(`spendParamBytes`), FfiConverterSequenceUByte.lower(`outputParamBytes`), _status)
                },
            )

        fun `withDefaultLocation`(): ZcashLocalTxProver =
            ZcashLocalTxProver(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashLocalTxProver_with_default_location(_status)
                },
            )
    }
}

public object FfiConverterTypeZcashLocalTxProver : FfiConverter<ZcashLocalTxProver, Pointer> {
    override fun lower(value: ZcashLocalTxProver): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashLocalTxProver {
        return ZcashLocalTxProver(value)
    }

    override fun read(buf: ByteBuffer): ZcashLocalTxProver {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashLocalTxProver) = 8

    override fun write(value: ZcashLocalTxProver, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashMemoBytesInterface {

    fun `data`(): List<UByte>
}

class ZcashMemoBytes(
    pointer: Pointer,
) : FFIObject(pointer), ZcashMemoBytesInterface {

    constructor(`data`: List<UByte>) :
        this(
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashMemoBytes_new(FfiConverterSequenceUByte.lower(`data`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashMemoBytes_object_free(this.pointer, status)
        }
    }

    override fun `data`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashMemoBytes_data(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `empty`(): ZcashMemoBytes =
            ZcashMemoBytes(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashMemoBytes_empty(_status)
                },
            )
    }
}

public object FfiConverterTypeZcashMemoBytes : FfiConverter<ZcashMemoBytes, Pointer> {
    override fun lower(value: ZcashMemoBytes): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashMemoBytes {
        return ZcashMemoBytes(value)
    }

    override fun read(buf: ByteBuffer): ZcashMemoBytes {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashMemoBytes) = 8

    override fun write(value: ZcashMemoBytes, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashNullifierDerivingKeyInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashNullifierDerivingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashNullifierDerivingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashNullifierDerivingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashNullifierDerivingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashNullifierDerivingKey =
            ZcashNullifierDerivingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashNullifierDerivingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashNullifierDerivingKey : FfiConverter<ZcashNullifierDerivingKey, Pointer> {
    override fun lower(value: ZcashNullifierDerivingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashNullifierDerivingKey {
        return ZcashNullifierDerivingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashNullifierDerivingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashNullifierDerivingKey) = 8

    override fun write(value: ZcashNullifierDerivingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardActionInterface {

    fun `nullifier`(): ZcashOrchardNullifier

    fun `cmx`(): ZcashExtractedNoteCommitment

    fun `encryptedNote`(): ZcashOrchardTransmittedNoteCiphertext

    fun `cvNet`(): ZcashOrchardValueCommitment
}

class ZcashOrchardAction(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardActionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardAction_object_free(this.pointer, status)
        }
    }

    override fun `nullifier`(): ZcashOrchardNullifier =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardAction_nullifier(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardNullifier.lift(it)
        }
    override fun `cmx`(): ZcashExtractedNoteCommitment =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardAction_cmx(it, _status)
            }
        }.let {
            FfiConverterTypeZcashExtractedNoteCommitment.lift(it)
        }
    override fun `encryptedNote`(): ZcashOrchardTransmittedNoteCiphertext =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardAction_encrypted_note(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardTransmittedNoteCiphertext.lift(it)
        }
    override fun `cvNet`(): ZcashOrchardValueCommitment =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardAction_cv_net(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardValueCommitment.lift(it)
        }
}

public object FfiConverterTypeZcashOrchardAction : FfiConverter<ZcashOrchardAction, Pointer> {
    override fun lower(value: ZcashOrchardAction): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardAction {
        return ZcashOrchardAction(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardAction {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardAction) = 8

    override fun write(value: ZcashOrchardAction, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardAddressInterface {

    fun `diversifier`(): ZcashOrchardDiversifier

    fun `toRawAddressBytes`(): List<UByte>
}

class ZcashOrchardAddress(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardAddressInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardAddress_object_free(this.pointer, status)
        }
    }

    override fun `diversifier`(): ZcashOrchardDiversifier =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardAddress_diversifier(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardDiversifier.lift(it)
        }
    override fun `toRawAddressBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardAddress_to_raw_address_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromRawAddressBytes`(`bytes`: List<UByte>): ZcashOrchardAddress =
            ZcashOrchardAddress(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardAddress_from_raw_address_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardAddress : FfiConverter<ZcashOrchardAddress, Pointer> {
    override fun lower(value: ZcashOrchardAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardAddress {
        return ZcashOrchardAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardAddress) = 8

    override fun write(value: ZcashOrchardAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardBundleInterface {

    fun `actions`(): List<ZcashOrchardAction>

    fun `flags`(): ZcashOrchardFlags

    fun `valueBalance`(): ZcashAmount

    fun `anchor`(): ZcashAnchor

    @Throws(ZcashException::class)
    fun `verifyProof`(`key`: ZcashVerifyingKey)

    @Throws(ZcashException::class)
    fun `decryptOutputWithKey`(`actionIdx`: ULong, `ivk`: ZcashOrchardIncomingViewingKey): ZcashOrchardDecryptOutput

    fun `decryptOutputWithKeys`(`ivks`: List<ZcashOrchardIncomingViewingKey>): List<ZcashOrchardDecryptOutputForIncomingKeys>

    @Throws(ZcashException::class)
    fun `recoverOutputWithOvk`(`actionIdx`: ULong, `ovk`: ZcashOrchardOutgoingViewingKey): ZcashOrchardDecryptOutput

    fun `recoverOutputsWithOvks`(`ovks`: List<ZcashOrchardOutgoingViewingKey>): List<ZcashOrchardDecryptOutputForOutgoingKeys>
}

class ZcashOrchardBundle(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardBundleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardBundle_object_free(this.pointer, status)
        }
    }

    override fun `actions`(): List<ZcashOrchardAction> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardBundle_actions(it, _status)
            }
        }.let {
            FfiConverterSequenceTypeZcashOrchardAction.lift(it)
        }
    override fun `flags`(): ZcashOrchardFlags =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardBundle_flags(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardFlags.lift(it)
        }
    override fun `valueBalance`(): ZcashAmount =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardBundle_value_balance(it, _status)
            }
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }
    override fun `anchor`(): ZcashAnchor =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardBundle_anchor(it, _status)
            }
        }.let {
            FfiConverterTypeZcashAnchor.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `verifyProof`(`key`: ZcashVerifyingKey) =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardBundle_verify_proof(it, FfiConverterTypeZcashVerifyingKey.lower(`key`), _status)
            }
        }

    @Throws(ZcashException::class)
    override fun `decryptOutputWithKey`(`actionIdx`: ULong, `ivk`: ZcashOrchardIncomingViewingKey): ZcashOrchardDecryptOutput =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardBundle_decrypt_output_with_key(it, FfiConverterULong.lower(`actionIdx`), FfiConverterTypeZcashOrchardIncomingViewingKey.lower(`ivk`), _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardDecryptOutput.lift(it)
        }
    override fun `decryptOutputWithKeys`(`ivks`: List<ZcashOrchardIncomingViewingKey>): List<ZcashOrchardDecryptOutputForIncomingKeys> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardBundle_decrypt_output_with_keys(it, FfiConverterSequenceTypeZcashOrchardIncomingViewingKey.lower(`ivks`), _status)
            }
        }.let {
            FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `recoverOutputWithOvk`(`actionIdx`: ULong, `ovk`: ZcashOrchardOutgoingViewingKey): ZcashOrchardDecryptOutput =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardBundle_recover_output_with_ovk(it, FfiConverterULong.lower(`actionIdx`), FfiConverterTypeZcashOrchardOutgoingViewingKey.lower(`ovk`), _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardDecryptOutput.lift(it)
        }
    override fun `recoverOutputsWithOvks`(`ovks`: List<ZcashOrchardOutgoingViewingKey>): List<ZcashOrchardDecryptOutputForOutgoingKeys> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardBundle_recover_outputs_with_ovks(it, FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey.lower(`ovks`), _status)
            }
        }.let {
            FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys.lift(it)
        }
}

public object FfiConverterTypeZcashOrchardBundle : FfiConverter<ZcashOrchardBundle, Pointer> {
    override fun lower(value: ZcashOrchardBundle): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardBundle {
        return ZcashOrchardBundle(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardBundle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardBundle) = 8

    override fun write(value: ZcashOrchardBundle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardDiversifierInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashOrchardDiversifier(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardDiversifierInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardDiversifier_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardDiversifier_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashOrchardDiversifier =
            ZcashOrchardDiversifier(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardDiversifier_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardDiversifier : FfiConverter<ZcashOrchardDiversifier, Pointer> {
    override fun lower(value: ZcashOrchardDiversifier): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardDiversifier {
        return ZcashOrchardDiversifier(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardDiversifier {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardDiversifier) = 8

    override fun write(value: ZcashOrchardDiversifier, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardDiversifierIndexInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashOrchardDiversifierIndex(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardDiversifierIndexInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardDiversifierIndex_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardDiversifierIndex_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`b`: List<UByte>): ZcashOrchardDiversifierIndex =
            ZcashOrchardDiversifierIndex(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardDiversifierIndex_from_bytes(FfiConverterSequenceUByte.lower(`b`), _status)
                },
            )

        fun `fromU32`(`i`: UInt): ZcashOrchardDiversifierIndex =
            ZcashOrchardDiversifierIndex(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardDiversifierIndex_from_u32(FfiConverterUInt.lower(`i`), _status)
                },
            )

        fun `fromU64`(`i`: ULong): ZcashOrchardDiversifierIndex =
            ZcashOrchardDiversifierIndex(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardDiversifierIndex_from_u64(FfiConverterULong.lower(`i`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardDiversifierIndex : FfiConverter<ZcashOrchardDiversifierIndex, Pointer> {
    override fun lower(value: ZcashOrchardDiversifierIndex): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardDiversifierIndex {
        return ZcashOrchardDiversifierIndex(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardDiversifierIndex {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardDiversifierIndex) = 8

    override fun write(value: ZcashOrchardDiversifierIndex, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardFlagsInterface {

    fun `spendsEnabled`(): Boolean

    fun `outputsEnabled`(): Boolean

    fun `toByte`(): UByte
}

class ZcashOrchardFlags(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardFlagsInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardFlags_object_free(this.pointer, status)
        }
    }

    override fun `spendsEnabled`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFlags_spends_enabled(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `outputsEnabled`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFlags_outputs_enabled(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `toByte`(): UByte =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFlags_to_byte(it, _status)
            }
        }.let {
            FfiConverterUByte.lift(it)
        }

    companion object {

        fun `fromParts`(`spendsEnabled`: Boolean, `outputsEnabled`: Boolean): ZcashOrchardFlags =
            ZcashOrchardFlags(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFlags_from_parts(FfiConverterBoolean.lower(`spendsEnabled`), FfiConverterBoolean.lower(`outputsEnabled`), _status)
                },
            )

        fun `fromByte`(`v`: UByte): ZcashOrchardFlags =
            ZcashOrchardFlags(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFlags_from_byte(FfiConverterUByte.lower(`v`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardFlags : FfiConverter<ZcashOrchardFlags, Pointer> {
    override fun lower(value: ZcashOrchardFlags): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardFlags {
        return ZcashOrchardFlags(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardFlags {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardFlags) = 8

    override fun write(value: ZcashOrchardFlags, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardFullViewingKeyInterface {

    fun `addressAt`(`j`: ZcashOrchardDiversifierIndex, `scope`: ZcashOrchardScope): ZcashOrchardAddress

    fun `address`(`d`: ZcashOrchardDiversifier, `scope`: ZcashOrchardScope): ZcashOrchardAddress

    fun `scopeForAddress`(`address`: ZcashOrchardAddress): ZcashOrchardScope?

    fun `toBytes`(): List<UByte>

    fun `toIvk`(`scope`: ZcashOrchardScope): ZcashOrchardIncomingViewingKey

    fun `toOvk`(`scope`: ZcashOrchardScope): ZcashOrchardOutgoingViewingKey
}

class ZcashOrchardFullViewingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardFullViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `addressAt`(`j`: ZcashOrchardDiversifierIndex, `scope`: ZcashOrchardScope): ZcashOrchardAddress =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFullViewingKey_address_at(it, FfiConverterTypeZcashOrchardDiversifierIndex.lower(`j`), FfiConverterTypeZcashOrchardScope.lower(`scope`), _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }
    override fun `address`(`d`: ZcashOrchardDiversifier, `scope`: ZcashOrchardScope): ZcashOrchardAddress =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFullViewingKey_address(it, FfiConverterTypeZcashOrchardDiversifier.lower(`d`), FfiConverterTypeZcashOrchardScope.lower(`scope`), _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }
    override fun `scopeForAddress`(`address`: ZcashOrchardAddress): ZcashOrchardScope? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFullViewingKey_scope_for_address(it, FfiConverterTypeZcashOrchardAddress.lower(`address`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashOrchardScope.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFullViewingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `toIvk`(`scope`: ZcashOrchardScope): ZcashOrchardIncomingViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFullViewingKey_to_ivk(it, FfiConverterTypeZcashOrchardScope.lower(`scope`), _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardIncomingViewingKey.lift(it)
        }
    override fun `toOvk`(`scope`: ZcashOrchardScope): ZcashOrchardOutgoingViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFullViewingKey_to_ovk(it, FfiConverterTypeZcashOrchardScope.lower(`scope`), _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardOutgoingViewingKey.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashOrchardFullViewingKey =
            ZcashOrchardFullViewingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardFullViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardFullViewingKey : FfiConverter<ZcashOrchardFullViewingKey, Pointer> {
    override fun lower(value: ZcashOrchardFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardFullViewingKey {
        return ZcashOrchardFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardFullViewingKey) = 8

    override fun write(value: ZcashOrchardFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardIncomingViewingKeyInterface {

    fun `toBytes`(): List<UByte>

    fun `diversifierIndex`(`addr`: ZcashOrchardAddress): ZcashOrchardDiversifierIndex?

    fun `addressAt`(`j`: ZcashOrchardDiversifierIndex): ZcashOrchardAddress

    fun `address`(`diversifier`: ZcashOrchardDiversifier): ZcashOrchardAddress
}

class ZcashOrchardIncomingViewingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardIncomingViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardIncomingViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardIncomingViewingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `diversifierIndex`(`addr`: ZcashOrchardAddress): ZcashOrchardDiversifierIndex? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardIncomingViewingKey_diversifier_index(it, FfiConverterTypeZcashOrchardAddress.lower(`addr`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashOrchardDiversifierIndex.lift(it)
        }
    override fun `addressAt`(`j`: ZcashOrchardDiversifierIndex): ZcashOrchardAddress =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardIncomingViewingKey_address_at(it, FfiConverterTypeZcashOrchardDiversifierIndex.lower(`j`), _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }
    override fun `address`(`diversifier`: ZcashOrchardDiversifier): ZcashOrchardAddress =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardIncomingViewingKey_address(it, FfiConverterTypeZcashOrchardDiversifier.lower(`diversifier`), _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashOrchardIncomingViewingKey =
            ZcashOrchardIncomingViewingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardIncomingViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardIncomingViewingKey : FfiConverter<ZcashOrchardIncomingViewingKey, Pointer> {
    override fun lower(value: ZcashOrchardIncomingViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardIncomingViewingKey {
        return ZcashOrchardIncomingViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardIncomingViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardIncomingViewingKey) = 8

    override fun write(value: ZcashOrchardIncomingViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardMerkleHashInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashOrchardMerkleHash(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardMerkleHashInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardMerkleHash_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardMerkleHash_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashOrchardMerkleHash =
            ZcashOrchardMerkleHash(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardMerkleHash_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )

        fun `fromCmx`(`cmx`: ZcashExtractedNoteCommitment): ZcashOrchardMerkleHash =
            ZcashOrchardMerkleHash(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardMerkleHash_from_cmx(FfiConverterTypeZcashExtractedNoteCommitment.lower(`cmx`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardMerkleHash : FfiConverter<ZcashOrchardMerkleHash, Pointer> {
    override fun lower(value: ZcashOrchardMerkleHash): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardMerkleHash {
        return ZcashOrchardMerkleHash(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardMerkleHash {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardMerkleHash) = 8

    override fun write(value: ZcashOrchardMerkleHash, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardMerklePathInterface {

    fun `root`(`cmx`: ZcashExtractedNoteCommitment): ZcashAnchor
}

class ZcashOrchardMerklePath(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardMerklePathInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardMerklePath_object_free(this.pointer, status)
        }
    }

    override fun `root`(`cmx`: ZcashExtractedNoteCommitment): ZcashAnchor =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardMerklePath_root(it, FfiConverterTypeZcashExtractedNoteCommitment.lower(`cmx`), _status)
            }
        }.let {
            FfiConverterTypeZcashAnchor.lift(it)
        }

    companion object {

        fun `fromParts`(`position`: UInt, `authPath`: List<ZcashOrchardMerkleHash>): ZcashOrchardMerklePath =
            ZcashOrchardMerklePath(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardMerklePath_from_parts(FfiConverterUInt.lower(`position`), FfiConverterSequenceTypeZcashOrchardMerkleHash.lower(`authPath`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardMerklePath : FfiConverter<ZcashOrchardMerklePath, Pointer> {
    override fun lower(value: ZcashOrchardMerklePath): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardMerklePath {
        return ZcashOrchardMerklePath(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardMerklePath {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardMerklePath) = 8

    override fun write(value: ZcashOrchardMerklePath, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardNoteInterface {

    fun `recipient`(): ZcashOrchardAddress

    fun `value`(): ZcashOrchardNoteValue

    fun `commitment`(): ZcashOrchardNoteCommitment
}

class ZcashOrchardNote(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardNoteInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardNote_object_free(this.pointer, status)
        }
    }

    override fun `recipient`(): ZcashOrchardAddress =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardNote_recipient(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardAddress.lift(it)
        }
    override fun `value`(): ZcashOrchardNoteValue =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardNote_value(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardNoteValue.lift(it)
        }
    override fun `commitment`(): ZcashOrchardNoteCommitment =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardNote_commitment(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardNoteCommitment.lift(it)
        }

    companion object {

        fun `fromParts`(`recipient`: ZcashOrchardAddress, `value`: ZcashOrchardNoteValue, `rho`: ZcashOrchardNullifier, `rseed`: ZcashOrchardRandomSeed): ZcashOrchardNote =
            ZcashOrchardNote(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardNote_from_parts(FfiConverterTypeZcashOrchardAddress.lower(`recipient`), FfiConverterTypeZcashOrchardNoteValue.lower(`value`), FfiConverterTypeZcashOrchardNullifier.lower(`rho`), FfiConverterTypeZcashOrchardRandomSeed.lower(`rseed`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardNote : FfiConverter<ZcashOrchardNote, Pointer> {
    override fun lower(value: ZcashOrchardNote): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardNote {
        return ZcashOrchardNote(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardNote {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardNote) = 8

    override fun write(value: ZcashOrchardNote, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardNoteCommitmentInterface {

    fun `toExtractedNoteCommitment`(): ZcashExtractedNoteCommitment
}

class ZcashOrchardNoteCommitment(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardNoteCommitmentInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardNoteCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toExtractedNoteCommitment`(): ZcashExtractedNoteCommitment =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardNoteCommitment_to_extracted_note_commitment(it, _status)
            }
        }.let {
            FfiConverterTypeZcashExtractedNoteCommitment.lift(it)
        }
}

public object FfiConverterTypeZcashOrchardNoteCommitment : FfiConverter<ZcashOrchardNoteCommitment, Pointer> {
    override fun lower(value: ZcashOrchardNoteCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardNoteCommitment {
        return ZcashOrchardNoteCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardNoteCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardNoteCommitment) = 8

    override fun write(value: ZcashOrchardNoteCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardNoteValueInterface {

    fun `value`(): ULong
}

class ZcashOrchardNoteValue(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardNoteValueInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardNoteValue_object_free(this.pointer, status)
        }
    }

    override fun `value`(): ULong =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardNoteValue_value(it, _status)
            }
        }.let {
            FfiConverterULong.lift(it)
        }

    companion object {

        fun `fromRaw`(`value`: ULong): ZcashOrchardNoteValue =
            ZcashOrchardNoteValue(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardNoteValue_from_raw(FfiConverterULong.lower(`value`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardNoteValue : FfiConverter<ZcashOrchardNoteValue, Pointer> {
    override fun lower(value: ZcashOrchardNoteValue): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardNoteValue {
        return ZcashOrchardNoteValue(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardNoteValue {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardNoteValue) = 8

    override fun write(value: ZcashOrchardNoteValue, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardNullifierInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashOrchardNullifier(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardNullifierInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardNullifier_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardNullifier_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashOrchardNullifier =
            ZcashOrchardNullifier(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardNullifier_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardNullifier : FfiConverter<ZcashOrchardNullifier, Pointer> {
    override fun lower(value: ZcashOrchardNullifier): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardNullifier {
        return ZcashOrchardNullifier(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardNullifier {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardNullifier) = 8

    override fun write(value: ZcashOrchardNullifier, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardOutgoingViewingKeyInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashOrchardOutgoingViewingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardOutgoingViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardOutgoingViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardOutgoingViewingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashOrchardOutgoingViewingKey =
            ZcashOrchardOutgoingViewingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardOutgoingViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardOutgoingViewingKey : FfiConverter<ZcashOrchardOutgoingViewingKey, Pointer> {
    override fun lower(value: ZcashOrchardOutgoingViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardOutgoingViewingKey {
        return ZcashOrchardOutgoingViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardOutgoingViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardOutgoingViewingKey) = 8

    override fun write(value: ZcashOrchardOutgoingViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardRandomSeedInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashOrchardRandomSeed(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardRandomSeedInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardRandomSeed_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardRandomSeed_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>, `rho`: ZcashOrchardNullifier): ZcashOrchardRandomSeed =
            ZcashOrchardRandomSeed(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardRandomSeed_from_bytes(FfiConverterSequenceUByte.lower(`data`), FfiConverterTypeZcashOrchardNullifier.lower(`rho`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardRandomSeed : FfiConverter<ZcashOrchardRandomSeed, Pointer> {
    override fun lower(value: ZcashOrchardRandomSeed): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardRandomSeed {
        return ZcashOrchardRandomSeed(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardRandomSeed {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardRandomSeed) = 8

    override fun write(value: ZcashOrchardRandomSeed, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardSpendingKeyInterface {

    fun `toBytes`(): List<UByte>

    fun `toFvk`(): ZcashOrchardFullViewingKey
}

class ZcashOrchardSpendingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardSpendingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardSpendingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardSpendingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `toFvk`(): ZcashOrchardFullViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardSpendingKey_to_fvk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardFullViewingKey.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashOrchardSpendingKey =
            ZcashOrchardSpendingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardSpendingKey_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )

        fun `fromZip32Seed`(`seed`: List<UByte>, `coinType`: UInt, `account`: UInt): ZcashOrchardSpendingKey =
            ZcashOrchardSpendingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardSpendingKey_from_zip32_seed(FfiConverterSequenceUByte.lower(`seed`), FfiConverterUInt.lower(`coinType`), FfiConverterUInt.lower(`account`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOrchardSpendingKey : FfiConverter<ZcashOrchardSpendingKey, Pointer> {
    override fun lower(value: ZcashOrchardSpendingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardSpendingKey {
        return ZcashOrchardSpendingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardSpendingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardSpendingKey) = 8

    override fun write(value: ZcashOrchardSpendingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardTransactionBuilderInterface {

    fun `addSpend`(`fvk`: ZcashOrchardFullViewingKey, `note`: ZcashOrchardNote, `merklePath`: ZcashOrchardMerklePath)

    @Throws(ZcashException::class)
    fun `addRecipient`(`ovk`: ZcashOrchardOutgoingViewingKey?, `recipient`: ZcashOrchardAddress, `value`: ULong, `memo`: List<UByte>?)

    @Throws(ZcashException::class)
    fun `build`(`keys`: List<ZcashOrchardSpendingKey>, `sighash`: List<UByte>): ZcashTransaction
}

class ZcashOrchardTransactionBuilder(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardTransactionBuilderInterface {

    constructor(`parameters`: ZcashConsensusParameters, `targetHeight`: ZcashBlockHeight, `expiryHeight`: ZcashBlockHeight, `anchor`: ZcashAnchor, `flags`: ZcashOrchardFlags) :
        this(
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardTransactionBuilder_new(FfiConverterTypeZcashConsensusParameters.lower(`parameters`), FfiConverterTypeZcashBlockHeight.lower(`targetHeight`), FfiConverterTypeZcashBlockHeight.lower(`expiryHeight`), FfiConverterTypeZcashAnchor.lower(`anchor`), FfiConverterTypeZcashOrchardFlags.lower(`flags`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardTransactionBuilder_object_free(this.pointer, status)
        }
    }

    override fun `addSpend`(`fvk`: ZcashOrchardFullViewingKey, `note`: ZcashOrchardNote, `merklePath`: ZcashOrchardMerklePath) =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardTransactionBuilder_add_spend(it, FfiConverterTypeZcashOrchardFullViewingKey.lower(`fvk`), FfiConverterTypeZcashOrchardNote.lower(`note`), FfiConverterTypeZcashOrchardMerklePath.lower(`merklePath`), _status)
            }
        }

    @Throws(ZcashException::class)
    override fun `addRecipient`(`ovk`: ZcashOrchardOutgoingViewingKey?, `recipient`: ZcashOrchardAddress, `value`: ULong, `memo`: List<UByte>?) =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardTransactionBuilder_add_recipient(it, FfiConverterOptionalTypeZcashOrchardOutgoingViewingKey.lower(`ovk`), FfiConverterTypeZcashOrchardAddress.lower(`recipient`), FfiConverterULong.lower(`value`), FfiConverterOptionalSequenceUByte.lower(`memo`), _status)
            }
        }

    @Throws(ZcashException::class)
    override fun `build`(`keys`: List<ZcashOrchardSpendingKey>, `sighash`: List<UByte>): ZcashTransaction =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardTransactionBuilder_build(it, FfiConverterSequenceTypeZcashOrchardSpendingKey.lower(`keys`), FfiConverterSequenceUByte.lower(`sighash`), _status)
            }
        }.let {
            FfiConverterTypeZcashTransaction.lift(it)
        }
}

public object FfiConverterTypeZcashOrchardTransactionBuilder : FfiConverter<ZcashOrchardTransactionBuilder, Pointer> {
    override fun lower(value: ZcashOrchardTransactionBuilder): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardTransactionBuilder {
        return ZcashOrchardTransactionBuilder(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardTransactionBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardTransactionBuilder) = 8

    override fun write(value: ZcashOrchardTransactionBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOrchardValueCommitmentInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashOrchardValueCommitment(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOrchardValueCommitmentInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOrchardValueCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOrchardValueCommitment_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashOrchardValueCommitment : FfiConverter<ZcashOrchardValueCommitment, Pointer> {
    override fun lower(value: ZcashOrchardValueCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOrchardValueCommitment {
        return ZcashOrchardValueCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashOrchardValueCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOrchardValueCommitment) = 8

    override fun write(value: ZcashOrchardValueCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOutPointInterface

class ZcashOutPoint(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOutPointInterface {

    constructor(`hash`: List<UByte>, `n`: UInt) :
        this(
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOutPoint_new(FfiConverterSequenceUByte.lower(`hash`), FfiConverterUInt.lower(`n`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOutPoint_object_free(this.pointer, status)
        }
    }
}

public object FfiConverterTypeZcashOutPoint : FfiConverter<ZcashOutPoint, Pointer> {
    override fun lower(value: ZcashOutPoint): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOutPoint {
        return ZcashOutPoint(value)
    }

    override fun read(buf: ByteBuffer): ZcashOutPoint {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOutPoint) = 8

    override fun write(value: ZcashOutPoint, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashOutgoingViewingKeyInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashOutgoingViewingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashOutgoingViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashOutgoingViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashOutgoingViewingKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`b`: List<UByte>): ZcashOutgoingViewingKey =
            ZcashOutgoingViewingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashOutgoingViewingKey_from_bytes(FfiConverterSequenceUByte.lower(`b`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashOutgoingViewingKey : FfiConverter<ZcashOutgoingViewingKey, Pointer> {
    override fun lower(value: ZcashOutgoingViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashOutgoingViewingKey {
        return ZcashOutgoingViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashOutgoingViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashOutgoingViewingKey) = 8

    override fun write(value: ZcashOutgoingViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashPaymentAddressInterface {

    fun `encode`(`params`: ZcashConsensusParameters): String

    fun `toBytes`(): List<UByte>

    fun `diversifier`(): ZcashDiversifier

    fun `pkD`(): ZcashSaplingDiversifiedTransmissionKey

    @Throws(ZcashException::class)
    fun `createNote`(`value`: ULong, `rseed`: ZcashRseed): ZcashSaplingNote
}

class ZcashPaymentAddress(
    pointer: Pointer,
) : FFIObject(pointer), ZcashPaymentAddressInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashPaymentAddress_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashPaymentAddress_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`), _status)
            }
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashPaymentAddress_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `diversifier`(): ZcashDiversifier =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashPaymentAddress_diversifier(it, _status)
            }
        }.let {
            FfiConverterTypeZcashDiversifier.lift(it)
        }
    override fun `pkD`(): ZcashSaplingDiversifiedTransmissionKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashPaymentAddress_pk_d(it, _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingDiversifiedTransmissionKey.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `createNote`(`value`: ULong, `rseed`: ZcashRseed): ZcashSaplingNote =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashPaymentAddress_create_note(it, FfiConverterULong.lower(`value`), FfiConverterTypeZcashRseed.lower(`rseed`), _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingNote.lift(it)
        }

    companion object {

        fun `fromBytes`(`bytes`: List<UByte>): ZcashPaymentAddress =
            ZcashPaymentAddress(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashPaymentAddress_from_bytes(FfiConverterSequenceUByte.lower(`bytes`), _status)
                },
            )

        fun `decode`(`params`: ZcashConsensusParameters, `input`: String): ZcashPaymentAddress =
            ZcashPaymentAddress(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashPaymentAddress_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`input`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashPaymentAddress : FfiConverter<ZcashPaymentAddress, Pointer> {
    override fun lower(value: ZcashPaymentAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashPaymentAddress {
        return ZcashPaymentAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashPaymentAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashPaymentAddress) = 8

    override fun write(value: ZcashPaymentAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashProofGenerationKeyInterface {

    fun `toViewingKey`(): ZcashViewingKey
}

class ZcashProofGenerationKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashProofGenerationKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashProofGenerationKey_object_free(this.pointer, status)
        }
    }

    override fun `toViewingKey`(): ZcashViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashProofGenerationKey_to_viewing_key(it, _status)
            }
        }.let {
            FfiConverterTypeZcashViewingKey.lift(it)
        }
}

public object FfiConverterTypeZcashProofGenerationKey : FfiConverter<ZcashProofGenerationKey, Pointer> {
    override fun lower(value: ZcashProofGenerationKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashProofGenerationKey {
        return ZcashProofGenerationKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashProofGenerationKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashProofGenerationKey) = 8

    override fun write(value: ZcashProofGenerationKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashProvingKeyInterface

class ZcashProvingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashProvingKeyInterface {

    constructor() :
        this(
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashProvingKey_new(_status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashProvingKey_object_free(this.pointer, status)
        }
    }
}

public object FfiConverterTypeZcashProvingKey : FfiConverter<ZcashProvingKey, Pointer> {
    override fun lower(value: ZcashProvingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashProvingKey {
        return ZcashProvingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashProvingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashProvingKey) = 8

    override fun write(value: ZcashProvingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashRecipientAddressInterface {

    fun `encode`(`params`: ZcashConsensusParameters): String
}

class ZcashRecipientAddress(
    pointer: Pointer,
) : FFIObject(pointer), ZcashRecipientAddressInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashRecipientAddress_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashRecipientAddress_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`), _status)
            }
        }.let {
            FfiConverterString.lift(it)
        }

    companion object {

        fun `decode`(`params`: ZcashConsensusParameters, `address`: String): ZcashRecipientAddress =
            ZcashRecipientAddress(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashRecipientAddress_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`address`), _status)
                },
            )

        fun `shielded`(`addr`: ZcashPaymentAddress): ZcashRecipientAddress =
            ZcashRecipientAddress(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashRecipientAddress_shielded(FfiConverterTypeZcashPaymentAddress.lower(`addr`), _status)
                },
            )

        fun `transparent`(`addr`: ZcashTransparentAddress): ZcashRecipientAddress =
            ZcashRecipientAddress(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashRecipientAddress_transparent(FfiConverterTypeZcashTransparentAddress.lower(`addr`), _status)
                },
            )

        fun `unified`(`addr`: ZcashUnifiedAddress): ZcashRecipientAddress =
            ZcashRecipientAddress(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashRecipientAddress_unified(FfiConverterTypeZcashUnifiedAddress.lower(`addr`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashRecipientAddress : FfiConverter<ZcashRecipientAddress, Pointer> {
    override fun lower(value: ZcashRecipientAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashRecipientAddress {
        return ZcashRecipientAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashRecipientAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashRecipientAddress) = 8

    override fun write(value: ZcashRecipientAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingBundleInterface {

    fun `shieldedSpends`(): List<ZcashSaplingSpendDescription>

    fun `shieldedOutputs`(): List<ZcashSaplingOutputDescription>

    fun `valueBalance`(): ZcashAmount
}

class ZcashSaplingBundle(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingBundleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingBundle_object_free(this.pointer, status)
        }
    }

    override fun `shieldedSpends`(): List<ZcashSaplingSpendDescription> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingBundle_shielded_spends(it, _status)
            }
        }.let {
            FfiConverterSequenceTypeZcashSaplingSpendDescription.lift(it)
        }
    override fun `shieldedOutputs`(): List<ZcashSaplingOutputDescription> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingBundle_shielded_outputs(it, _status)
            }
        }.let {
            FfiConverterSequenceTypeZcashSaplingOutputDescription.lift(it)
        }
    override fun `valueBalance`(): ZcashAmount =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingBundle_value_balance(it, _status)
            }
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingBundle : FfiConverter<ZcashSaplingBundle, Pointer> {
    override fun lower(value: ZcashSaplingBundle): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingBundle {
        return ZcashSaplingBundle(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingBundle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingBundle) = 8

    override fun write(value: ZcashSaplingBundle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingDiversifiedTransmissionKeyInterface

class ZcashSaplingDiversifiedTransmissionKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingDiversifiedTransmissionKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingDiversifiedTransmissionKey_object_free(this.pointer, status)
        }
    }
}

public object FfiConverterTypeZcashSaplingDiversifiedTransmissionKey : FfiConverter<ZcashSaplingDiversifiedTransmissionKey, Pointer> {
    override fun lower(value: ZcashSaplingDiversifiedTransmissionKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingDiversifiedTransmissionKey {
        return ZcashSaplingDiversifiedTransmissionKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingDiversifiedTransmissionKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingDiversifiedTransmissionKey) = 8

    override fun write(value: ZcashSaplingDiversifiedTransmissionKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingExtractedNoteCommitmentInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashSaplingExtractedNoteCommitment(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingExtractedNoteCommitmentInterface {

    constructor(`data`: List<UByte>) :
        this(
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingExtractedNoteCommitment_new(FfiConverterSequenceUByte.lower(`data`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingExtractedNoteCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingExtractedNoteCommitment_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingExtractedNoteCommitment : FfiConverter<ZcashSaplingExtractedNoteCommitment, Pointer> {
    override fun lower(value: ZcashSaplingExtractedNoteCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingExtractedNoteCommitment {
        return ZcashSaplingExtractedNoteCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingExtractedNoteCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingExtractedNoteCommitment) = 8

    override fun write(value: ZcashSaplingExtractedNoteCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingIvkInterface {

    fun `toPaymentAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress?

    fun `toRepr`(): List<UByte>
}

class ZcashSaplingIvk(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingIvkInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingIvk_object_free(this.pointer, status)
        }
    }

    override fun `toPaymentAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingIvk_to_payment_address(it, FfiConverterTypeZcashDiversifier.lower(`diversifier`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `toRepr`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingIvk_to_repr(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingIvk : FfiConverter<ZcashSaplingIvk, Pointer> {
    override fun lower(value: ZcashSaplingIvk): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingIvk {
        return ZcashSaplingIvk(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingIvk {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingIvk) = 8

    override fun write(value: ZcashSaplingIvk, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingMerklePathInterface {

    fun `authPath`(): List<ZcashAuthPath>

    fun `position`(): ULong
}

class ZcashSaplingMerklePath(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingMerklePathInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingMerklePath_object_free(this.pointer, status)
        }
    }

    override fun `authPath`(): List<ZcashAuthPath> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingMerklePath_auth_path(it, _status)
            }
        }.let {
            FfiConverterSequenceTypeZcashAuthPath.lift(it)
        }
    override fun `position`(): ULong =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingMerklePath_position(it, _status)
            }
        }.let {
            FfiConverterULong.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingMerklePath : FfiConverter<ZcashSaplingMerklePath, Pointer> {
    override fun lower(value: ZcashSaplingMerklePath): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingMerklePath {
        return ZcashSaplingMerklePath(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingMerklePath {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingMerklePath) = 8

    override fun write(value: ZcashSaplingMerklePath, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingMetadataInterface {

    fun `spendIndex`(`n`: ULong): ULong?

    fun `outputIndex`(`n`: ULong): ULong?
}

class ZcashSaplingMetadata(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingMetadataInterface {

    constructor() :
        this(
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingMetadata_new(_status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingMetadata_object_free(this.pointer, status)
        }
    }

    override fun `spendIndex`(`n`: ULong): ULong? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingMetadata_spend_index(it, FfiConverterULong.lower(`n`), _status)
            }
        }.let {
            FfiConverterOptionalULong.lift(it)
        }
    override fun `outputIndex`(`n`: ULong): ULong? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingMetadata_output_index(it, FfiConverterULong.lower(`n`), _status)
            }
        }.let {
            FfiConverterOptionalULong.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingMetadata : FfiConverter<ZcashSaplingMetadata, Pointer> {
    override fun lower(value: ZcashSaplingMetadata): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingMetadata {
        return ZcashSaplingMetadata(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingMetadata {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingMetadata) = 8

    override fun write(value: ZcashSaplingMetadata, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingNodeInterface

class ZcashSaplingNode(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingNodeInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingNode_object_free(this.pointer, status)
        }
    }

    companion object {

        fun `fromCmu`(`cmu`: ZcashSaplingExtractedNoteCommitment): ZcashSaplingNode =
            ZcashSaplingNode(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingNode_from_cmu(FfiConverterTypeZcashSaplingExtractedNoteCommitment.lower(`cmu`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashSaplingNode : FfiConverter<ZcashSaplingNode, Pointer> {
    override fun lower(value: ZcashSaplingNode): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingNode {
        return ZcashSaplingNode(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingNode {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingNode) = 8

    override fun write(value: ZcashSaplingNode, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingNoteInterface {

    fun `value`(): ZcashSaplingNoteValue

    fun `cmu`(): ZcashSaplingExtractedNoteCommitment
}

class ZcashSaplingNote(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingNoteInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingNote_object_free(this.pointer, status)
        }
    }

    override fun `value`(): ZcashSaplingNoteValue =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingNote_value(it, _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingNoteValue.lift(it)
        }
    override fun `cmu`(): ZcashSaplingExtractedNoteCommitment =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingNote_cmu(it, _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(it)
        }

    companion object {

        fun `fromParts`(`recipient`: ZcashPaymentAddress, `value`: ZcashSaplingNoteValue, `rseed`: ZcashRseed): ZcashSaplingNote =
            ZcashSaplingNote(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingNote_from_parts(FfiConverterTypeZcashPaymentAddress.lower(`recipient`), FfiConverterTypeZcashSaplingNoteValue.lower(`value`), FfiConverterTypeZcashRseed.lower(`rseed`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashSaplingNote : FfiConverter<ZcashSaplingNote, Pointer> {
    override fun lower(value: ZcashSaplingNote): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingNote {
        return ZcashSaplingNote(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingNote {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingNote) = 8

    override fun write(value: ZcashSaplingNote, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingNoteValueInterface {

    fun `inner`(): ULong
}

class ZcashSaplingNoteValue(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingNoteValueInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingNoteValue_object_free(this.pointer, status)
        }
    }

    override fun `inner`(): ULong =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingNoteValue_inner(it, _status)
            }
        }.let {
            FfiConverterULong.lift(it)
        }

    companion object {

        fun `fromRaw`(`data`: ULong): ZcashSaplingNoteValue =
            ZcashSaplingNoteValue(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingNoteValue_from_raw(FfiConverterULong.lower(`data`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashSaplingNoteValue : FfiConverter<ZcashSaplingNoteValue, Pointer> {
    override fun lower(value: ZcashSaplingNoteValue): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingNoteValue {
        return ZcashSaplingNoteValue(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingNoteValue {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingNoteValue) = 8

    override fun write(value: ZcashSaplingNoteValue, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingNullifierInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashSaplingNullifier(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingNullifierInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingNullifier_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingNullifier_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingNullifier : FfiConverter<ZcashSaplingNullifier, Pointer> {
    override fun lower(value: ZcashSaplingNullifier): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingNullifier {
        return ZcashSaplingNullifier(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingNullifier {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingNullifier) = 8

    override fun write(value: ZcashSaplingNullifier, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingOutputDescriptionInterface {

    fun `cv`(): ZcashSaplingValueCommitment

    fun `cmu`(): ZcashSaplingExtractedNoteCommitment
}

class ZcashSaplingOutputDescription(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingOutputDescriptionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingOutputDescription_object_free(this.pointer, status)
        }
    }

    override fun `cv`(): ZcashSaplingValueCommitment =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingOutputDescription_cv(it, _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingValueCommitment.lift(it)
        }
    override fun `cmu`(): ZcashSaplingExtractedNoteCommitment =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingOutputDescription_cmu(it, _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingExtractedNoteCommitment.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingOutputDescription : FfiConverter<ZcashSaplingOutputDescription, Pointer> {
    override fun lower(value: ZcashSaplingOutputDescription): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingOutputDescription {
        return ZcashSaplingOutputDescription(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingOutputDescription {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingOutputDescription) = 8

    override fun write(value: ZcashSaplingOutputDescription, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingPublicKeyInterface {

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
}

class ZcashSaplingPublicKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingPublicKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingPublicKey_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingPublicKey_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingPublicKey : FfiConverter<ZcashSaplingPublicKey, Pointer> {
    override fun lower(value: ZcashSaplingPublicKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingPublicKey {
        return ZcashSaplingPublicKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingPublicKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingPublicKey) = 8

    override fun write(value: ZcashSaplingPublicKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingSpendDescriptionInterface {

    fun `cv`(): ZcashSaplingValueCommitment

    fun `anchor`(): List<UByte>

    fun `nullifier`(): ZcashSaplingNullifier

    fun `rk`(): ZcashSaplingPublicKey
}

class ZcashSaplingSpendDescription(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingSpendDescriptionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingSpendDescription_object_free(this.pointer, status)
        }
    }

    override fun `cv`(): ZcashSaplingValueCommitment =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingSpendDescription_cv(it, _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingValueCommitment.lift(it)
        }
    override fun `anchor`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingSpendDescription_anchor(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `nullifier`(): ZcashSaplingNullifier =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingSpendDescription_nullifier(it, _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingNullifier.lift(it)
        }
    override fun `rk`(): ZcashSaplingPublicKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingSpendDescription_rk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingPublicKey.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingSpendDescription : FfiConverter<ZcashSaplingSpendDescription, Pointer> {
    override fun lower(value: ZcashSaplingSpendDescription): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingSpendDescription {
        return ZcashSaplingSpendDescription(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingSpendDescription {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingSpendDescription) = 8

    override fun write(value: ZcashSaplingSpendDescription, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashSaplingValueCommitmentInterface {

    fun `toBytes`(): List<UByte>
}

class ZcashSaplingValueCommitment(
    pointer: Pointer,
) : FFIObject(pointer), ZcashSaplingValueCommitmentInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashSaplingValueCommitment_object_free(this.pointer, status)
        }
    }

    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashSaplingValueCommitment_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashSaplingValueCommitment : FfiConverter<ZcashSaplingValueCommitment, Pointer> {
    override fun lower(value: ZcashSaplingValueCommitment): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashSaplingValueCommitment {
        return ZcashSaplingValueCommitment(value)
    }

    override fun read(buf: ByteBuffer): ZcashSaplingValueCommitment {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashSaplingValueCommitment) = 8

    override fun write(value: ZcashSaplingValueCommitment, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashScriptInterface {

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
}

class ZcashScript(
    pointer: Pointer,
) : FFIObject(pointer), ZcashScriptInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashScript_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashScript_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashScript =
            ZcashScript(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashScript_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashScript : FfiConverter<ZcashScript, Pointer> {
    override fun lower(value: ZcashScript): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashScript {
        return ZcashScript(value)
    }

    override fun read(buf: ByteBuffer): ZcashScript {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashScript) = 8

    override fun write(value: ZcashScript, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashTransactionInterface {

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>

    fun `txid`(): ZcashTxId

    fun `version`(): ZcashTxVersion

    fun `consensusBranchId`(): ZcashBranchId

    fun `lockTime`(): UInt

    fun `expiryHeight`(): ZcashBlockHeight

    fun `transparentBundle`(): ZcashTransparentBundle?

    fun `saplingBundle`(): ZcashSaplingBundle?

    fun `orchardBundle`(): ZcashOrchardBundle?
}

class ZcashTransaction(
    pointer: Pointer,
) : FFIObject(pointer), ZcashTransactionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashTransaction_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `txid`(): ZcashTxId =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_txid(it, _status)
            }
        }.let {
            FfiConverterTypeZcashTxId.lift(it)
        }
    override fun `version`(): ZcashTxVersion =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_version(it, _status)
            }
        }.let {
            FfiConverterTypeZcashTxVersion.lift(it)
        }
    override fun `consensusBranchId`(): ZcashBranchId =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_consensus_branch_id(it, _status)
            }
        }.let {
            FfiConverterTypeZcashBranchId.lift(it)
        }
    override fun `lockTime`(): UInt =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_lock_time(it, _status)
            }
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `expiryHeight`(): ZcashBlockHeight =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_expiry_height(it, _status)
            }
        }.let {
            FfiConverterTypeZcashBlockHeight.lift(it)
        }
    override fun `transparentBundle`(): ZcashTransparentBundle? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_transparent_bundle(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashTransparentBundle.lift(it)
        }
    override fun `saplingBundle`(): ZcashSaplingBundle? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_sapling_bundle(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashSaplingBundle.lift(it)
        }
    override fun `orchardBundle`(): ZcashOrchardBundle? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_orchard_bundle(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashOrchardBundle.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>, `consensusBranchId`: ZcashBranchId): ZcashTransaction =
            ZcashTransaction(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashTransaction_from_bytes(FfiConverterSequenceUByte.lower(`data`), FfiConverterTypeZcashBranchId.lower(`consensusBranchId`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashTransaction : FfiConverter<ZcashTransaction, Pointer> {
    override fun lower(value: ZcashTransaction): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTransaction {
        return ZcashTransaction(value)
    }

    override fun read(buf: ByteBuffer): ZcashTransaction {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTransaction) = 8

    override fun write(value: ZcashTransaction, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashTransactionBuilderInterface {

    fun `addSaplingSpend`(`extsk`: ZcashExtendedSpendingKey, `diversifier`: ZcashDiversifier, `note`: ZcashSaplingNote, `merklePath`: ZcashSaplingMerklePath)

    fun `addSaplingOutput`(`ovk`: ZcashOutgoingViewingKey?, `to`: ZcashPaymentAddress, `value`: ZcashAmount, `memo`: ZcashMemoBytes)

    fun `addTransparentInput`(`sk`: SecpSecretKey, `utxo`: ZcashOutPoint, `coin`: ZcashTxOut)

    fun `addTransparentOutput`(`to`: ZcashTransparentAddress, `value`: ZcashAmount)

    @Throws(ZcashException::class)
    fun `build`(`prover`: ZcashLocalTxProver, `feeRule`: ZcashFeeRules): ZcashTransactionAndSaplingMetadata
}

class ZcashTransactionBuilder(
    pointer: Pointer,
) : FFIObject(pointer), ZcashTransactionBuilderInterface {

    constructor(`parameters`: ZcashConsensusParameters, `blockHeight`: ZcashBlockHeight) :
        this(
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransactionBuilder_new(FfiConverterTypeZcashConsensusParameters.lower(`parameters`), FfiConverterTypeZcashBlockHeight.lower(`blockHeight`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashTransactionBuilder_object_free(this.pointer, status)
        }
    }

    override fun `addSaplingSpend`(`extsk`: ZcashExtendedSpendingKey, `diversifier`: ZcashDiversifier, `note`: ZcashSaplingNote, `merklePath`: ZcashSaplingMerklePath) =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransactionBuilder_add_sapling_spend(it, FfiConverterTypeZcashExtendedSpendingKey.lower(`extsk`), FfiConverterTypeZcashDiversifier.lower(`diversifier`), FfiConverterTypeZcashSaplingNote.lower(`note`), FfiConverterTypeZcashSaplingMerklePath.lower(`merklePath`), _status)
            }
        }

    override fun `addSaplingOutput`(`ovk`: ZcashOutgoingViewingKey?, `to`: ZcashPaymentAddress, `value`: ZcashAmount, `memo`: ZcashMemoBytes) =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransactionBuilder_add_sapling_output(it, FfiConverterOptionalTypeZcashOutgoingViewingKey.lower(`ovk`), FfiConverterTypeZcashPaymentAddress.lower(`to`), FfiConverterTypeZcashAmount.lower(`value`), FfiConverterTypeZcashMemoBytes.lower(`memo`), _status)
            }
        }

    override fun `addTransparentInput`(`sk`: SecpSecretKey, `utxo`: ZcashOutPoint, `coin`: ZcashTxOut) =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransactionBuilder_add_transparent_input(it, FfiConverterTypeSecpSecretKey.lower(`sk`), FfiConverterTypeZcashOutPoint.lower(`utxo`), FfiConverterTypeZcashTxOut.lower(`coin`), _status)
            }
        }

    override fun `addTransparentOutput`(`to`: ZcashTransparentAddress, `value`: ZcashAmount) =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransactionBuilder_add_transparent_output(it, FfiConverterTypeZcashTransparentAddress.lower(`to`), FfiConverterTypeZcashAmount.lower(`value`), _status)
            }
        }

    @Throws(ZcashException::class)
    override fun `build`(`prover`: ZcashLocalTxProver, `feeRule`: ZcashFeeRules): ZcashTransactionAndSaplingMetadata =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransactionBuilder_build(it, FfiConverterTypeZcashLocalTxProver.lower(`prover`), FfiConverterTypeZcashFeeRules.lower(`feeRule`), _status)
            }
        }.let {
            FfiConverterTypeZcashTransactionAndSaplingMetadata.lift(it)
        }
}

public object FfiConverterTypeZcashTransactionBuilder : FfiConverter<ZcashTransactionBuilder, Pointer> {
    override fun lower(value: ZcashTransactionBuilder): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTransactionBuilder {
        return ZcashTransactionBuilder(value)
    }

    override fun read(buf: ByteBuffer): ZcashTransactionBuilder {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTransactionBuilder) = 8

    override fun write(value: ZcashTransactionBuilder, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashTransparentAddressInterface {

    fun `encode`(`params`: ZcashConsensusParameters): String

    fun `isPublicKey`(): Boolean

    fun `isScript`(): Boolean

    fun `script`(): ZcashScript

    fun `toBytes`(): List<UByte>
}

class ZcashTransparentAddress(
    pointer: Pointer,
) : FFIObject(pointer), ZcashTransparentAddressInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashTransparentAddress_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentAddress_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`), _status)
            }
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `isPublicKey`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentAddress_is_public_key(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `isScript`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentAddress_is_script(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `script`(): ZcashScript =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentAddress_script(it, _status)
            }
        }.let {
            FfiConverterTypeZcashScript.lift(it)
        }
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentAddress_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromPublicKey`(`data`: List<UByte>): ZcashTransparentAddress =
            ZcashTransparentAddress(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentAddress_from_public_key(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )

        fun `fromScript`(`data`: List<UByte>): ZcashTransparentAddress =
            ZcashTransparentAddress(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentAddress_from_script(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )

        fun `decode`(`params`: ZcashConsensusParameters, `input`: String): ZcashTransparentAddress =
            ZcashTransparentAddress(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentAddress_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`input`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashTransparentAddress : FfiConverter<ZcashTransparentAddress, Pointer> {
    override fun lower(value: ZcashTransparentAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTransparentAddress {
        return ZcashTransparentAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashTransparentAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTransparentAddress) = 8

    override fun write(value: ZcashTransparentAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashTransparentBundleInterface {

    fun `isCoinbase`(): Boolean

    fun `vin`(): List<ZcashTxIn>

    fun `vout`(): List<ZcashTxOut>
}

class ZcashTransparentBundle(
    pointer: Pointer,
) : FFIObject(pointer), ZcashTransparentBundleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashTransparentBundle_object_free(this.pointer, status)
        }
    }

    override fun `isCoinbase`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentBundle_is_coinbase(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `vin`(): List<ZcashTxIn> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentBundle_vin(it, _status)
            }
        }.let {
            FfiConverterSequenceTypeZcashTxIn.lift(it)
        }
    override fun `vout`(): List<ZcashTxOut> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTransparentBundle_vout(it, _status)
            }
        }.let {
            FfiConverterSequenceTypeZcashTxOut.lift(it)
        }
}

public object FfiConverterTypeZcashTransparentBundle : FfiConverter<ZcashTransparentBundle, Pointer> {
    override fun lower(value: ZcashTransparentBundle): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTransparentBundle {
        return ZcashTransparentBundle(value)
    }

    override fun read(buf: ByteBuffer): ZcashTransparentBundle {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTransparentBundle) = 8

    override fun write(value: ZcashTransparentBundle, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashTxIdInterface {

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
}

class ZcashTxId(
    pointer: Pointer,
) : FFIObject(pointer), ZcashTxIdInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashTxId_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxId_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashTxId =
            ZcashTxId(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashTxId_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashTxId : FfiConverter<ZcashTxId, Pointer> {
    override fun lower(value: ZcashTxId): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTxId {
        return ZcashTxId(value)
    }

    override fun read(buf: ByteBuffer): ZcashTxId {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTxId) = 8

    override fun write(value: ZcashTxId, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashTxInInterface {

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>
}

class ZcashTxIn(
    pointer: Pointer,
) : FFIObject(pointer), ZcashTxInInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashTxIn_object_free(this.pointer, status)
        }
    }

    @Throws(ZcashException::class)
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxIn_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
}

public object FfiConverterTypeZcashTxIn : FfiConverter<ZcashTxIn, Pointer> {
    override fun lower(value: ZcashTxIn): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTxIn {
        return ZcashTxIn(value)
    }

    override fun read(buf: ByteBuffer): ZcashTxIn {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTxIn) = 8

    override fun write(value: ZcashTxIn, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashTxOutInterface {

    fun `value`(): ZcashAmount

    fun `scriptPubkey`(): ZcashScript

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>

    fun `recipientAddress`(): ZcashTransparentAddress?
}

class ZcashTxOut(
    pointer: Pointer,
) : FFIObject(pointer), ZcashTxOutInterface {

    constructor(`value`: ZcashAmount, `scriptPubkey`: ZcashScript) :
        this(
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxOut_new(FfiConverterTypeZcashAmount.lower(`value`), FfiConverterTypeZcashScript.lower(`scriptPubkey`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashTxOut_object_free(this.pointer, status)
        }
    }

    override fun `value`(): ZcashAmount =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxOut_value(it, _status)
            }
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }
    override fun `scriptPubkey`(): ZcashScript =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxOut_script_pubkey(it, _status)
            }
        }.let {
            FfiConverterTypeZcashScript.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxOut_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `recipientAddress`(): ZcashTransparentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxOut_recipient_address(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashTransparentAddress.lift(it)
        }
}

public object FfiConverterTypeZcashTxOut : FfiConverter<ZcashTxOut, Pointer> {
    override fun lower(value: ZcashTxOut): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTxOut {
        return ZcashTxOut(value)
    }

    override fun read(buf: ByteBuffer): ZcashTxOut {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTxOut) = 8

    override fun write(value: ZcashTxOut, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashTxVersionInterface {

    fun `selection`(): ZcashTxVersionSelection

    fun `header`(): UInt

    fun `versionGroupId`(): UInt

    @Throws(ZcashException::class)
    fun `toBytes`(): List<UByte>

    fun `hasSprout`(): Boolean

    fun `hasOverwinter`(): Boolean

    fun `hasSapling`(): Boolean

    fun `hasOrchard`(): Boolean
}

class ZcashTxVersion(
    pointer: Pointer,
) : FFIObject(pointer), ZcashTxVersionInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashTxVersion_object_free(this.pointer, status)
        }
    }

    override fun `selection`(): ZcashTxVersionSelection =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_selection(it, _status)
            }
        }.let {
            FfiConverterTypeZcashTxVersionSelection.lift(it)
        }
    override fun `header`(): UInt =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_header(it, _status)
            }
        }.let {
            FfiConverterUInt.lift(it)
        }
    override fun `versionGroupId`(): UInt =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_version_group_id(it, _status)
            }
        }.let {
            FfiConverterUInt.lift(it)
        }

    @Throws(ZcashException::class)
    override fun `toBytes`(): List<UByte> =
        callWithPointer {
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_to_bytes(it, _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }
    override fun `hasSprout`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_has_sprout(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `hasOverwinter`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_has_overwinter(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `hasSapling`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_has_sapling(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }
    override fun `hasOrchard`(): Boolean =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_has_orchard(it, _status)
            }
        }.let {
            FfiConverterBoolean.lift(it)
        }

    companion object {

        fun `fromBytes`(`data`: List<UByte>): ZcashTxVersion =
            ZcashTxVersion(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_from_bytes(FfiConverterSequenceUByte.lower(`data`), _status)
                },
            )

        fun `suggestedForBranch`(`consensusBranchId`: ZcashBranchId): ZcashTxVersion =
            ZcashTxVersion(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashTxVersion_suggested_for_branch(FfiConverterTypeZcashBranchId.lower(`consensusBranchId`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashTxVersion : FfiConverter<ZcashTxVersion, Pointer> {
    override fun lower(value: ZcashTxVersion): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashTxVersion {
        return ZcashTxVersion(value)
    }

    override fun read(buf: ByteBuffer): ZcashTxVersion {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashTxVersion) = 8

    override fun write(value: ZcashTxVersion, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashUnifiedAddressInterface {

    fun `orchard`(): ZcashOrchardAddress?

    fun `sapling`(): ZcashPaymentAddress?

    fun `transparent`(): ZcashTransparentAddress?

    fun `encode`(`params`: ZcashConsensusParameters): String
}

class ZcashUnifiedAddress(
    pointer: Pointer,
) : FFIObject(pointer), ZcashUnifiedAddressInterface {

    constructor(`orchard`: ZcashOrchardAddress?, `sapling`: ZcashPaymentAddress?, `transparent`: ZcashTransparentAddress?) :
        this(
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedAddress_new(FfiConverterOptionalTypeZcashOrchardAddress.lower(`orchard`), FfiConverterOptionalTypeZcashPaymentAddress.lower(`sapling`), FfiConverterOptionalTypeZcashTransparentAddress.lower(`transparent`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashUnifiedAddress_object_free(this.pointer, status)
        }
    }

    override fun `orchard`(): ZcashOrchardAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedAddress_orchard(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashOrchardAddress.lift(it)
        }
    override fun `sapling`(): ZcashPaymentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedAddress_sapling(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
    override fun `transparent`(): ZcashTransparentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedAddress_transparent(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashTransparentAddress.lift(it)
        }
    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedAddress_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`), _status)
            }
        }.let {
            FfiConverterString.lift(it)
        }

    companion object {

        fun `decode`(`params`: ZcashConsensusParameters, `address`: String): ZcashUnifiedAddress =
            ZcashUnifiedAddress(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedAddress_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`address`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashUnifiedAddress : FfiConverter<ZcashUnifiedAddress, Pointer> {
    override fun lower(value: ZcashUnifiedAddress): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashUnifiedAddress {
        return ZcashUnifiedAddress(value)
    }

    override fun read(buf: ByteBuffer): ZcashUnifiedAddress {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashUnifiedAddress) = 8

    override fun write(value: ZcashUnifiedAddress, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashUnifiedFullViewingKeyInterface {

    fun `encode`(`params`: ZcashConsensusParameters): String

    fun `transparent`(): ZcashAccountPubKey?

    fun `sapling`(): ZcashDiversifiableFullViewingKey?

    fun `orchard`(): ZcashOrchardFullViewingKey?

    fun `address`(`j`: ZcashDiversifierIndex): ZcashUnifiedAddress?

    fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashUnifiedAddressAndDiversifierIndex?

    fun `defaultAddress`(): ZcashUnifiedAddressAndDiversifierIndex
}

class ZcashUnifiedFullViewingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashUnifiedFullViewingKeyInterface {

    constructor(`transparent`: ZcashAccountPubKey?, `sapling`: ZcashDiversifiableFullViewingKey?, `orchard`: ZcashOrchardFullViewingKey?) :
        this(
            rustCallWithError(ZcashException) { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedFullViewingKey_new(FfiConverterOptionalTypeZcashAccountPubKey.lower(`transparent`), FfiConverterOptionalTypeZcashDiversifiableFullViewingKey.lower(`sapling`), FfiConverterOptionalTypeZcashOrchardFullViewingKey.lower(`orchard`), _status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashUnifiedFullViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `encode`(`params`: ZcashConsensusParameters): String =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedFullViewingKey_encode(it, FfiConverterTypeZcashConsensusParameters.lower(`params`), _status)
            }
        }.let {
            FfiConverterString.lift(it)
        }
    override fun `transparent`(): ZcashAccountPubKey? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedFullViewingKey_transparent(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashAccountPubKey.lift(it)
        }
    override fun `sapling`(): ZcashDiversifiableFullViewingKey? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedFullViewingKey_sapling(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashDiversifiableFullViewingKey.lift(it)
        }
    override fun `orchard`(): ZcashOrchardFullViewingKey? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedFullViewingKey_orchard(it, _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashOrchardFullViewingKey.lift(it)
        }
    override fun `address`(`j`: ZcashDiversifierIndex): ZcashUnifiedAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedFullViewingKey_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashUnifiedAddress.lift(it)
        }
    override fun `findAddress`(`j`: ZcashDiversifierIndex): ZcashUnifiedAddressAndDiversifierIndex? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedFullViewingKey_find_address(it, FfiConverterTypeZcashDiversifierIndex.lower(`j`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashUnifiedAddressAndDiversifierIndex.lift(it)
        }
    override fun `defaultAddress`(): ZcashUnifiedAddressAndDiversifierIndex =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedFullViewingKey_default_address(it, _status)
            }
        }.let {
            FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.lift(it)
        }

    companion object {

        fun `decode`(`params`: ZcashConsensusParameters, `encoded`: String): ZcashUnifiedFullViewingKey =
            ZcashUnifiedFullViewingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedFullViewingKey_decode(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterString.lower(`encoded`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashUnifiedFullViewingKey : FfiConverter<ZcashUnifiedFullViewingKey, Pointer> {
    override fun lower(value: ZcashUnifiedFullViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashUnifiedFullViewingKey {
        return ZcashUnifiedFullViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashUnifiedFullViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashUnifiedFullViewingKey) = 8

    override fun write(value: ZcashUnifiedFullViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashUnifiedSpendingKeyInterface {

    fun `toUnifiedFullViewingKey`(): ZcashUnifiedFullViewingKey

    fun `transparent`(): ZcashAccountPrivKey

    fun `sapling`(): ZcashExtendedSpendingKey

    fun `orchard`(): ZcashOrchardSpendingKey

    fun `toBytes`(`era`: ZcashKeysEra): List<UByte>
}

class ZcashUnifiedSpendingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashUnifiedSpendingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashUnifiedSpendingKey_object_free(this.pointer, status)
        }
    }

    override fun `toUnifiedFullViewingKey`(): ZcashUnifiedFullViewingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedSpendingKey_to_unified_full_viewing_key(it, _status)
            }
        }.let {
            FfiConverterTypeZcashUnifiedFullViewingKey.lift(it)
        }
    override fun `transparent`(): ZcashAccountPrivKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedSpendingKey_transparent(it, _status)
            }
        }.let {
            FfiConverterTypeZcashAccountPrivKey.lift(it)
        }
    override fun `sapling`(): ZcashExtendedSpendingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedSpendingKey_sapling(it, _status)
            }
        }.let {
            FfiConverterTypeZcashExtendedSpendingKey.lift(it)
        }
    override fun `orchard`(): ZcashOrchardSpendingKey =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedSpendingKey_orchard(it, _status)
            }
        }.let {
            FfiConverterTypeZcashOrchardSpendingKey.lift(it)
        }
    override fun `toBytes`(`era`: ZcashKeysEra): List<UByte> =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedSpendingKey_to_bytes(it, FfiConverterTypeZcashKeysEra.lower(`era`), _status)
            }
        }.let {
            FfiConverterSequenceUByte.lift(it)
        }

    companion object {

        fun `fromSeed`(`params`: ZcashConsensusParameters, `seed`: List<UByte>, `accountId`: ZcashAccountId): ZcashUnifiedSpendingKey =
            ZcashUnifiedSpendingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedSpendingKey_from_seed(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterSequenceUByte.lower(`seed`), FfiConverterTypeZcashAccountId.lower(`accountId`), _status)
                },
            )

        fun `fromBytes`(`era`: ZcashKeysEra, `encoded`: List<UByte>): ZcashUnifiedSpendingKey =
            ZcashUnifiedSpendingKey(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashUnifiedSpendingKey_from_bytes(FfiConverterTypeZcashKeysEra.lower(`era`), FfiConverterSequenceUByte.lower(`encoded`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashUnifiedSpendingKey : FfiConverter<ZcashUnifiedSpendingKey, Pointer> {
    override fun lower(value: ZcashUnifiedSpendingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashUnifiedSpendingKey {
        return ZcashUnifiedSpendingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashUnifiedSpendingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashUnifiedSpendingKey) = 8

    override fun write(value: ZcashUnifiedSpendingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashVerifyingKeyInterface

class ZcashVerifyingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashVerifyingKeyInterface {

    constructor() :
        this(
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashVerifyingKey_new(_status)
            },
        )

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashVerifyingKey_object_free(this.pointer, status)
        }
    }
}

public object FfiConverterTypeZcashVerifyingKey : FfiConverter<ZcashVerifyingKey, Pointer> {
    override fun lower(value: ZcashVerifyingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashVerifyingKey {
        return ZcashVerifyingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashVerifyingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashVerifyingKey) = 8

    override fun write(value: ZcashVerifyingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashViewingKeyInterface {

    fun `ivk`(): ZcashSaplingIvk

    fun `toPaymentAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress?
}

class ZcashViewingKey(
    pointer: Pointer,
) : FFIObject(pointer), ZcashViewingKeyInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashViewingKey_object_free(this.pointer, status)
        }
    }

    override fun `ivk`(): ZcashSaplingIvk =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashViewingKey_ivk(it, _status)
            }
        }.let {
            FfiConverterTypeZcashSaplingIvk.lift(it)
        }
    override fun `toPaymentAddress`(`diversifier`: ZcashDiversifier): ZcashPaymentAddress? =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashViewingKey_to_payment_address(it, FfiConverterTypeZcashDiversifier.lower(`diversifier`), _status)
            }
        }.let {
            FfiConverterOptionalTypeZcashPaymentAddress.lift(it)
        }
}

public object FfiConverterTypeZcashViewingKey : FfiConverter<ZcashViewingKey, Pointer> {
    override fun lower(value: ZcashViewingKey): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashViewingKey {
        return ZcashViewingKey(value)
    }

    override fun read(buf: ByteBuffer): ZcashViewingKey {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashViewingKey) = 8

    override fun write(value: ZcashViewingKey, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

public interface ZcashZip317FeeRuleInterface {

    fun `marginalFee`(): ZcashAmount
}

class ZcashZip317FeeRule(
    pointer: Pointer,
) : FFIObject(pointer), ZcashZip317FeeRuleInterface {

    /**
     * Disconnect the object from the underlying Rust object.
     *
     * It can be called more than once, but once called, interacting with the object
     * causes an `IllegalStateException`.
     *
     * Clients **must** call this method once done with the object, or cause a memory leak.
     */
    protected override fun freeRustArcPtr() {
        rustCall() { status ->
            _UniFFILib.INSTANCE.ffi_zcash_e53_ZcashZip317FeeRule_object_free(this.pointer, status)
        }
    }

    override fun `marginalFee`(): ZcashAmount =
        callWithPointer {
            rustCall() { _status ->
                _UniFFILib.INSTANCE.zcash_e53_ZcashZip317FeeRule_marginal_fee(it, _status)
            }
        }.let {
            FfiConverterTypeZcashAmount.lift(it)
        }

    companion object {

        fun `standard`(): ZcashZip317FeeRule =
            ZcashZip317FeeRule(
                rustCall() { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashZip317FeeRule_standard(_status)
                },
            )

        fun `nonStandard`(`marginalFee`: ZcashAmount, `graceActions`: ULong, `p2pkhStandardInputSize`: ULong, `p2pkhStandardOutputSize`: ULong): ZcashZip317FeeRule =
            ZcashZip317FeeRule(
                rustCallWithError(ZcashException) { _status ->
                    _UniFFILib.INSTANCE.zcash_e53_ZcashZip317FeeRule_non_standard(FfiConverterTypeZcashAmount.lower(`marginalFee`), FfiConverterULong.lower(`graceActions`), FfiConverterULong.lower(`p2pkhStandardInputSize`), FfiConverterULong.lower(`p2pkhStandardOutputSize`), _status)
                },
            )
    }
}

public object FfiConverterTypeZcashZip317FeeRule : FfiConverter<ZcashZip317FeeRule, Pointer> {
    override fun lower(value: ZcashZip317FeeRule): Pointer = value.callWithPointer { it }

    override fun lift(value: Pointer): ZcashZip317FeeRule {
        return ZcashZip317FeeRule(value)
    }

    override fun read(buf: ByteBuffer): ZcashZip317FeeRule {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ZcashZip317FeeRule) = 8

    override fun write(value: ZcashZip317FeeRule, buf: ByteBuffer) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

data class ZcashAccountId(
    var `id`: UInt,
)

public object FfiConverterTypeZcashAccountId : FfiConverterRustBuffer<ZcashAccountId> {
    override fun read(buf: ByteBuffer): ZcashAccountId {
        return ZcashAccountId(
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: ZcashAccountId) = (
        FfiConverterUInt.allocationSize(value.`id`)
        )

    override fun write(value: ZcashAccountId, buf: ByteBuffer) {
        FfiConverterUInt.write(value.`id`, buf)
    }
}

data class ZcashAuthPath(
    var `node`: ZcashSaplingNode,
    var `bool`: Boolean,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`node`,
            this.`bool`,
        )
    }
}

public object FfiConverterTypeZcashAuthPath : FfiConverterRustBuffer<ZcashAuthPath> {
    override fun read(buf: ByteBuffer): ZcashAuthPath {
        return ZcashAuthPath(
            FfiConverterTypeZcashSaplingNode.read(buf),
            FfiConverterBoolean.read(buf),
        )
    }

    override fun allocationSize(value: ZcashAuthPath) = (
        FfiConverterTypeZcashSaplingNode.allocationSize(value.`node`) +
            FfiConverterBoolean.allocationSize(value.`bool`)
        )

    override fun write(value: ZcashAuthPath, buf: ByteBuffer) {
        FfiConverterTypeZcashSaplingNode.write(value.`node`, buf)
        FfiConverterBoolean.write(value.`bool`, buf)
    }
}

data class ZcashDiversifierIndexAndPaymentAddress(
    var `diversifierIndex`: ZcashDiversifierIndex,
    var `address`: ZcashPaymentAddress,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`diversifierIndex`,
            this.`address`,
        )
    }
}

public object FfiConverterTypeZcashDiversifierIndexAndPaymentAddress : FfiConverterRustBuffer<ZcashDiversifierIndexAndPaymentAddress> {
    override fun read(buf: ByteBuffer): ZcashDiversifierIndexAndPaymentAddress {
        return ZcashDiversifierIndexAndPaymentAddress(
            FfiConverterTypeZcashDiversifierIndex.read(buf),
            FfiConverterTypeZcashPaymentAddress.read(buf),
        )
    }

    override fun allocationSize(value: ZcashDiversifierIndexAndPaymentAddress) = (
        FfiConverterTypeZcashDiversifierIndex.allocationSize(value.`diversifierIndex`) +
            FfiConverterTypeZcashPaymentAddress.allocationSize(value.`address`)
        )

    override fun write(value: ZcashDiversifierIndexAndPaymentAddress, buf: ByteBuffer) {
        FfiConverterTypeZcashDiversifierIndex.write(value.`diversifierIndex`, buf)
        FfiConverterTypeZcashPaymentAddress.write(value.`address`, buf)
    }
}

data class ZcashDiversifierIndexAndScope(
    var `diversifierIndex`: ZcashDiversifierIndex,
    var `scope`: ZcashScope,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`diversifierIndex`,
            this.`scope`,
        )
    }
}

public object FfiConverterTypeZcashDiversifierIndexAndScope : FfiConverterRustBuffer<ZcashDiversifierIndexAndScope> {
    override fun read(buf: ByteBuffer): ZcashDiversifierIndexAndScope {
        return ZcashDiversifierIndexAndScope(
            FfiConverterTypeZcashDiversifierIndex.read(buf),
            FfiConverterTypeZcashScope.read(buf),
        )
    }

    override fun allocationSize(value: ZcashDiversifierIndexAndScope) = (
        FfiConverterTypeZcashDiversifierIndex.allocationSize(value.`diversifierIndex`) +
            FfiConverterTypeZcashScope.allocationSize(value.`scope`)
        )

    override fun write(value: ZcashDiversifierIndexAndScope, buf: ByteBuffer) {
        FfiConverterTypeZcashDiversifierIndex.write(value.`diversifierIndex`, buf)
        FfiConverterTypeZcashScope.write(value.`scope`, buf)
    }
}

data class ZcashInternalOvkExternalOvk(
    var `internalOvk`: ZcashInternalOvk,
    var `externalOvk`: ZcashExternalOvk,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`internalOvk`,
            this.`externalOvk`,
        )
    }
}

public object FfiConverterTypeZcashInternalOvkExternalOvk : FfiConverterRustBuffer<ZcashInternalOvkExternalOvk> {
    override fun read(buf: ByteBuffer): ZcashInternalOvkExternalOvk {
        return ZcashInternalOvkExternalOvk(
            FfiConverterTypeZcashInternalOvk.read(buf),
            FfiConverterTypeZcashExternalOvk.read(buf),
        )
    }

    override fun allocationSize(value: ZcashInternalOvkExternalOvk) = (
        FfiConverterTypeZcashInternalOvk.allocationSize(value.`internalOvk`) +
            FfiConverterTypeZcashExternalOvk.allocationSize(value.`externalOvk`)
        )

    override fun write(value: ZcashInternalOvkExternalOvk, buf: ByteBuffer) {
        FfiConverterTypeZcashInternalOvk.write(value.`internalOvk`, buf)
        FfiConverterTypeZcashExternalOvk.write(value.`externalOvk`, buf)
    }
}

data class ZcashOrchardDecryptOutput(
    var `note`: ZcashOrchardNote,
    var `address`: ZcashOrchardAddress,
    var `data`: List<UByte>,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`note`,
            this.`address`,
            this.`data`,
        )
    }
}

public object FfiConverterTypeZcashOrchardDecryptOutput : FfiConverterRustBuffer<ZcashOrchardDecryptOutput> {
    override fun read(buf: ByteBuffer): ZcashOrchardDecryptOutput {
        return ZcashOrchardDecryptOutput(
            FfiConverterTypeZcashOrchardNote.read(buf),
            FfiConverterTypeZcashOrchardAddress.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: ZcashOrchardDecryptOutput) = (
        FfiConverterTypeZcashOrchardNote.allocationSize(value.`note`) +
            FfiConverterTypeZcashOrchardAddress.allocationSize(value.`address`) +
            FfiConverterSequenceUByte.allocationSize(value.`data`)
        )

    override fun write(value: ZcashOrchardDecryptOutput, buf: ByteBuffer) {
        FfiConverterTypeZcashOrchardNote.write(value.`note`, buf)
        FfiConverterTypeZcashOrchardAddress.write(value.`address`, buf)
        FfiConverterSequenceUByte.write(value.`data`, buf)
    }
}

data class ZcashOrchardDecryptOutputForIncomingKeys(
    var `idx`: ULong,
    var `key`: ZcashOrchardIncomingViewingKey,
    var `note`: ZcashOrchardNote,
    var `address`: ZcashOrchardAddress,
    var `data`: List<UByte>,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`idx`,
            this.`key`,
            this.`note`,
            this.`address`,
            this.`data`,
        )
    }
}

public object FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys : FfiConverterRustBuffer<ZcashOrchardDecryptOutputForIncomingKeys> {
    override fun read(buf: ByteBuffer): ZcashOrchardDecryptOutputForIncomingKeys {
        return ZcashOrchardDecryptOutputForIncomingKeys(
            FfiConverterULong.read(buf),
            FfiConverterTypeZcashOrchardIncomingViewingKey.read(buf),
            FfiConverterTypeZcashOrchardNote.read(buf),
            FfiConverterTypeZcashOrchardAddress.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: ZcashOrchardDecryptOutputForIncomingKeys) = (
        FfiConverterULong.allocationSize(value.`idx`) +
            FfiConverterTypeZcashOrchardIncomingViewingKey.allocationSize(value.`key`) +
            FfiConverterTypeZcashOrchardNote.allocationSize(value.`note`) +
            FfiConverterTypeZcashOrchardAddress.allocationSize(value.`address`) +
            FfiConverterSequenceUByte.allocationSize(value.`data`)
        )

    override fun write(value: ZcashOrchardDecryptOutputForIncomingKeys, buf: ByteBuffer) {
        FfiConverterULong.write(value.`idx`, buf)
        FfiConverterTypeZcashOrchardIncomingViewingKey.write(value.`key`, buf)
        FfiConverterTypeZcashOrchardNote.write(value.`note`, buf)
        FfiConverterTypeZcashOrchardAddress.write(value.`address`, buf)
        FfiConverterSequenceUByte.write(value.`data`, buf)
    }
}

data class ZcashOrchardDecryptOutputForOutgoingKeys(
    var `idx`: ULong,
    var `key`: ZcashOrchardOutgoingViewingKey,
    var `note`: ZcashOrchardNote,
    var `address`: ZcashOrchardAddress,
    var `data`: List<UByte>,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`idx`,
            this.`key`,
            this.`note`,
            this.`address`,
            this.`data`,
        )
    }
}

public object FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys : FfiConverterRustBuffer<ZcashOrchardDecryptOutputForOutgoingKeys> {
    override fun read(buf: ByteBuffer): ZcashOrchardDecryptOutputForOutgoingKeys {
        return ZcashOrchardDecryptOutputForOutgoingKeys(
            FfiConverterULong.read(buf),
            FfiConverterTypeZcashOrchardOutgoingViewingKey.read(buf),
            FfiConverterTypeZcashOrchardNote.read(buf),
            FfiConverterTypeZcashOrchardAddress.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: ZcashOrchardDecryptOutputForOutgoingKeys) = (
        FfiConverterULong.allocationSize(value.`idx`) +
            FfiConverterTypeZcashOrchardOutgoingViewingKey.allocationSize(value.`key`) +
            FfiConverterTypeZcashOrchardNote.allocationSize(value.`note`) +
            FfiConverterTypeZcashOrchardAddress.allocationSize(value.`address`) +
            FfiConverterSequenceUByte.allocationSize(value.`data`)
        )

    override fun write(value: ZcashOrchardDecryptOutputForOutgoingKeys, buf: ByteBuffer) {
        FfiConverterULong.write(value.`idx`, buf)
        FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value.`key`, buf)
        FfiConverterTypeZcashOrchardNote.write(value.`note`, buf)
        FfiConverterTypeZcashOrchardAddress.write(value.`address`, buf)
        FfiConverterSequenceUByte.write(value.`data`, buf)
    }
}

data class ZcashOrchardTransmittedNoteCiphertext(
    var `epkBytes`: List<UByte>,
    var `encCiphertext`: List<UByte>,
    var `outCiphertext`: List<UByte>,
)

public object FfiConverterTypeZcashOrchardTransmittedNoteCiphertext : FfiConverterRustBuffer<ZcashOrchardTransmittedNoteCiphertext> {
    override fun read(buf: ByteBuffer): ZcashOrchardTransmittedNoteCiphertext {
        return ZcashOrchardTransmittedNoteCiphertext(
            FfiConverterSequenceUByte.read(buf),
            FfiConverterSequenceUByte.read(buf),
            FfiConverterSequenceUByte.read(buf),
        )
    }

    override fun allocationSize(value: ZcashOrchardTransmittedNoteCiphertext) = (
        FfiConverterSequenceUByte.allocationSize(value.`epkBytes`) +
            FfiConverterSequenceUByte.allocationSize(value.`encCiphertext`) +
            FfiConverterSequenceUByte.allocationSize(value.`outCiphertext`)
        )

    override fun write(value: ZcashOrchardTransmittedNoteCiphertext, buf: ByteBuffer) {
        FfiConverterSequenceUByte.write(value.`epkBytes`, buf)
        FfiConverterSequenceUByte.write(value.`encCiphertext`, buf)
        FfiConverterSequenceUByte.write(value.`outCiphertext`, buf)
    }
}

data class ZcashPayment(
    var `recipentAddress`: ZcashRecipientAddress,
    var `amount`: Long,
    var `memo`: ZcashMemoBytes?,
    var `label`: String?,
    var `message`: String?,
    var `otherParams`: List<ZcashPaymentParam>,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`recipentAddress`,
            this.`amount`,
            this.`memo`,
            this.`label`,
            this.`message`,
            this.`otherParams`,
        )
    }
}

public object FfiConverterTypeZcashPayment : FfiConverterRustBuffer<ZcashPayment> {
    override fun read(buf: ByteBuffer): ZcashPayment {
        return ZcashPayment(
            FfiConverterTypeZcashRecipientAddress.read(buf),
            FfiConverterLong.read(buf),
            FfiConverterOptionalTypeZcashMemoBytes.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterSequenceTypeZcashPaymentParam.read(buf),
        )
    }

    override fun allocationSize(value: ZcashPayment) = (
        FfiConverterTypeZcashRecipientAddress.allocationSize(value.`recipentAddress`) +
            FfiConverterLong.allocationSize(value.`amount`) +
            FfiConverterOptionalTypeZcashMemoBytes.allocationSize(value.`memo`) +
            FfiConverterOptionalString.allocationSize(value.`label`) +
            FfiConverterOptionalString.allocationSize(value.`message`) +
            FfiConverterSequenceTypeZcashPaymentParam.allocationSize(value.`otherParams`)
        )

    override fun write(value: ZcashPayment, buf: ByteBuffer) {
        FfiConverterTypeZcashRecipientAddress.write(value.`recipentAddress`, buf)
        FfiConverterLong.write(value.`amount`, buf)
        FfiConverterOptionalTypeZcashMemoBytes.write(value.`memo`, buf)
        FfiConverterOptionalString.write(value.`label`, buf)
        FfiConverterOptionalString.write(value.`message`, buf)
        FfiConverterSequenceTypeZcashPaymentParam.write(value.`otherParams`, buf)
    }
}

data class ZcashPaymentParam(
    var `key`: String,
    var `value`: String,
)

public object FfiConverterTypeZcashPaymentParam : FfiConverterRustBuffer<ZcashPaymentParam> {
    override fun read(buf: ByteBuffer): ZcashPaymentParam {
        return ZcashPaymentParam(
            FfiConverterString.read(buf),
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ZcashPaymentParam) = (
        FfiConverterString.allocationSize(value.`key`) +
            FfiConverterString.allocationSize(value.`value`)
        )

    override fun write(value: ZcashPaymentParam, buf: ByteBuffer) {
        FfiConverterString.write(value.`key`, buf)
        FfiConverterString.write(value.`value`, buf)
    }
}

data class ZcashTransactionAndSaplingMetadata(
    var `transaction`: ZcashTransaction,
    var `saplingMetadata`: ZcashSaplingMetadata,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`transaction`,
            this.`saplingMetadata`,
        )
    }
}

public object FfiConverterTypeZcashTransactionAndSaplingMetadata : FfiConverterRustBuffer<ZcashTransactionAndSaplingMetadata> {
    override fun read(buf: ByteBuffer): ZcashTransactionAndSaplingMetadata {
        return ZcashTransactionAndSaplingMetadata(
            FfiConverterTypeZcashTransaction.read(buf),
            FfiConverterTypeZcashSaplingMetadata.read(buf),
        )
    }

    override fun allocationSize(value: ZcashTransactionAndSaplingMetadata) = (
        FfiConverterTypeZcashTransaction.allocationSize(value.`transaction`) +
            FfiConverterTypeZcashSaplingMetadata.allocationSize(value.`saplingMetadata`)
        )

    override fun write(value: ZcashTransactionAndSaplingMetadata, buf: ByteBuffer) {
        FfiConverterTypeZcashTransaction.write(value.`transaction`, buf)
        FfiConverterTypeZcashSaplingMetadata.write(value.`saplingMetadata`, buf)
    }
}

data class ZcashTransparentAddressAndIndex(
    var `transparentAddress`: ZcashTransparentAddress,
    var `index`: UInt,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`transparentAddress`,
            this.`index`,
        )
    }
}

public object FfiConverterTypeZcashTransparentAddressAndIndex : FfiConverterRustBuffer<ZcashTransparentAddressAndIndex> {
    override fun read(buf: ByteBuffer): ZcashTransparentAddressAndIndex {
        return ZcashTransparentAddressAndIndex(
            FfiConverterTypeZcashTransparentAddress.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: ZcashTransparentAddressAndIndex) = (
        FfiConverterTypeZcashTransparentAddress.allocationSize(value.`transparentAddress`) +
            FfiConverterUInt.allocationSize(value.`index`)
        )

    override fun write(value: ZcashTransparentAddressAndIndex, buf: ByteBuffer) {
        FfiConverterTypeZcashTransparentAddress.write(value.`transparentAddress`, buf)
        FfiConverterUInt.write(value.`index`, buf)
    }
}

data class ZcashUnifiedAddressAndDiversifierIndex(
    var `address`: ZcashUnifiedAddress,
    var `diversifierIndex`: ZcashDiversifierIndex,
) : Disposable {

    @Suppress("UNNECESSARY_SAFE_CALL") // codegen is much simpler if we unconditionally emit safe calls here
    override fun destroy() {
        Disposable.destroy(
            this.`address`,
            this.`diversifierIndex`,
        )
    }
}

public object FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex : FfiConverterRustBuffer<ZcashUnifiedAddressAndDiversifierIndex> {
    override fun read(buf: ByteBuffer): ZcashUnifiedAddressAndDiversifierIndex {
        return ZcashUnifiedAddressAndDiversifierIndex(
            FfiConverterTypeZcashUnifiedAddress.read(buf),
            FfiConverterTypeZcashDiversifierIndex.read(buf),
        )
    }

    override fun allocationSize(value: ZcashUnifiedAddressAndDiversifierIndex) = (
        FfiConverterTypeZcashUnifiedAddress.allocationSize(value.`address`) +
            FfiConverterTypeZcashDiversifierIndex.allocationSize(value.`diversifierIndex`)
        )

    override fun write(value: ZcashUnifiedAddressAndDiversifierIndex, buf: ByteBuffer) {
        FfiConverterTypeZcashUnifiedAddress.write(value.`address`, buf)
        FfiConverterTypeZcashDiversifierIndex.write(value.`diversifierIndex`, buf)
    }
}

enum class ZcashBranchId {

    SPROUT,
    OVERWINTER,
    SAPLING,
    BLOSSOM,
    HEARTWOOD,
    CANOPY,
    NU5,
}

public object FfiConverterTypeZcashBranchId : FfiConverterRustBuffer<ZcashBranchId> {
    override fun read(buf: ByteBuffer) = try {
        ZcashBranchId.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashBranchId) = 4

    override fun write(value: ZcashBranchId, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}

sealed class ZcashChildIndex {
    data class NonHardened(
        val `v`: UInt,
    ) : ZcashChildIndex()
    data class Hardened(
        val `v`: UInt,
    ) : ZcashChildIndex()
}

public object FfiConverterTypeZcashChildIndex : FfiConverterRustBuffer<ZcashChildIndex> {
    override fun read(buf: ByteBuffer): ZcashChildIndex {
        return when (buf.getInt()) {
            1 -> ZcashChildIndex.NonHardened(
                FfiConverterUInt.read(buf),
            )
            2 -> ZcashChildIndex.Hardened(
                FfiConverterUInt.read(buf),
            )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ZcashChildIndex) = when (value) {
        is ZcashChildIndex.NonHardened -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4 +
                    FfiConverterUInt.allocationSize(value.`v`)
                )
        }
        is ZcashChildIndex.Hardened -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4 +
                    FfiConverterUInt.allocationSize(value.`v`)
                )
        }
    }

    override fun write(value: ZcashChildIndex, buf: ByteBuffer) {
        when (value) {
            is ZcashChildIndex.NonHardened -> {
                buf.putInt(1)
                FfiConverterUInt.write(value.`v`, buf)
                Unit
            }
            is ZcashChildIndex.Hardened -> {
                buf.putInt(2)
                FfiConverterUInt.write(value.`v`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

enum class ZcashConsensusParameters {

    MAIN_NETWORK,
    TEST_NETWORK,
}

public object FfiConverterTypeZcashConsensusParameters : FfiConverterRustBuffer<ZcashConsensusParameters> {
    override fun read(buf: ByteBuffer) = try {
        ZcashConsensusParameters.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashConsensusParameters) = 4

    override fun write(value: ZcashConsensusParameters, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}

sealed class ZcashFeeRules {
    object FixedStandard : ZcashFeeRules()

    data class FixedNonStandard(
        val `amount`: ULong,
    ) : ZcashFeeRules()
    object Zip317Standard : ZcashFeeRules()

    data class Zip317NonStandard(
        val `marginalFee`: ULong,
        val `graceActions`: ULong,
        val `p2pkhStandardInputSize`: ULong,
        val `p2pkhStandardOutputSize`: ULong,
    ) : ZcashFeeRules()
}

public object FfiConverterTypeZcashFeeRules : FfiConverterRustBuffer<ZcashFeeRules> {
    override fun read(buf: ByteBuffer): ZcashFeeRules {
        return when (buf.getInt()) {
            1 -> ZcashFeeRules.FixedStandard
            2 -> ZcashFeeRules.FixedNonStandard(
                FfiConverterULong.read(buf),
            )
            3 -> ZcashFeeRules.Zip317Standard
            4 -> ZcashFeeRules.Zip317NonStandard(
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
                FfiConverterULong.read(buf),
            )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ZcashFeeRules) = when (value) {
        is ZcashFeeRules.FixedStandard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                )
        }
        is ZcashFeeRules.FixedNonStandard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4 +
                    FfiConverterULong.allocationSize(value.`amount`)
                )
        }
        is ZcashFeeRules.Zip317Standard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                )
        }
        is ZcashFeeRules.Zip317NonStandard -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4 +
                    FfiConverterULong.allocationSize(value.`marginalFee`) +
                    FfiConverterULong.allocationSize(value.`graceActions`) +
                    FfiConverterULong.allocationSize(value.`p2pkhStandardInputSize`) +
                    FfiConverterULong.allocationSize(value.`p2pkhStandardOutputSize`)
                )
        }
    }

    override fun write(value: ZcashFeeRules, buf: ByteBuffer) {
        when (value) {
            is ZcashFeeRules.FixedStandard -> {
                buf.putInt(1)
                Unit
            }
            is ZcashFeeRules.FixedNonStandard -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`amount`, buf)
                Unit
            }
            is ZcashFeeRules.Zip317Standard -> {
                buf.putInt(3)
                Unit
            }
            is ZcashFeeRules.Zip317NonStandard -> {
                buf.putInt(4)
                FfiConverterULong.write(value.`marginalFee`, buf)
                FfiConverterULong.write(value.`graceActions`, buf)
                FfiConverterULong.write(value.`p2pkhStandardInputSize`, buf)
                FfiConverterULong.write(value.`p2pkhStandardOutputSize`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

enum class ZcashKeySeed {

    S128,
    S256,
    S512,
}

public object FfiConverterTypeZcashKeySeed : FfiConverterRustBuffer<ZcashKeySeed> {
    override fun read(buf: ByteBuffer) = try {
        ZcashKeySeed.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashKeySeed) = 4

    override fun write(value: ZcashKeySeed, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}

enum class ZcashKeysEra {

    ORCHARD,
}

public object FfiConverterTypeZcashKeysEra : FfiConverterRustBuffer<ZcashKeysEra> {
    override fun read(buf: ByteBuffer) = try {
        ZcashKeysEra.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashKeysEra) = 4

    override fun write(value: ZcashKeysEra, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}

enum class ZcashOrchardScope {

    EXTERNAL,
    INTERNAL,
}

public object FfiConverterTypeZcashOrchardScope : FfiConverterRustBuffer<ZcashOrchardScope> {
    override fun read(buf: ByteBuffer) = try {
        ZcashOrchardScope.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashOrchardScope) = 4

    override fun write(value: ZcashOrchardScope, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}

sealed class ZcashRseed {
    data class BeforeZip212(
        val `frData`: List<UByte>,
    ) : ZcashRseed()
    data class AfterZip212(
        val `data`: List<UByte>,
    ) : ZcashRseed()
}

public object FfiConverterTypeZcashRseed : FfiConverterRustBuffer<ZcashRseed> {
    override fun read(buf: ByteBuffer): ZcashRseed {
        return when (buf.getInt()) {
            1 -> ZcashRseed.BeforeZip212(
                FfiConverterSequenceUByte.read(buf),
            )
            2 -> ZcashRseed.AfterZip212(
                FfiConverterSequenceUByte.read(buf),
            )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ZcashRseed) = when (value) {
        is ZcashRseed.BeforeZip212 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4 +
                    FfiConverterSequenceUByte.allocationSize(value.`frData`)
                )
        }
        is ZcashRseed.AfterZip212 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4 +
                    FfiConverterSequenceUByte.allocationSize(value.`data`)
                )
        }
    }

    override fun write(value: ZcashRseed, buf: ByteBuffer) {
        when (value) {
            is ZcashRseed.BeforeZip212 -> {
                buf.putInt(1)
                FfiConverterSequenceUByte.write(value.`frData`, buf)
                Unit
            }
            is ZcashRseed.AfterZip212 -> {
                buf.putInt(2)
                FfiConverterSequenceUByte.write(value.`data`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

enum class ZcashScope {

    EXTERNAL,
    INTERNAL,
}

public object FfiConverterTypeZcashScope : FfiConverterRustBuffer<ZcashScope> {
    override fun read(buf: ByteBuffer) = try {
        ZcashScope.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: ZcashScope) = 4

    override fun write(value: ZcashScope, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}

sealed class ZcashTxVersionSelection {
    data class Sprout(
        val `v`: UInt,
    ) : ZcashTxVersionSelection()
    object Overwinter : ZcashTxVersionSelection()

    object Sapling : ZcashTxVersionSelection()

    object Zip225 : ZcashTxVersionSelection()
}

public object FfiConverterTypeZcashTxVersionSelection : FfiConverterRustBuffer<ZcashTxVersionSelection> {
    override fun read(buf: ByteBuffer): ZcashTxVersionSelection {
        return when (buf.getInt()) {
            1 -> ZcashTxVersionSelection.Sprout(
                FfiConverterUInt.read(buf),
            )
            2 -> ZcashTxVersionSelection.Overwinter
            3 -> ZcashTxVersionSelection.Sapling
            4 -> ZcashTxVersionSelection.Zip225
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ZcashTxVersionSelection) = when (value) {
        is ZcashTxVersionSelection.Sprout -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4 +
                    FfiConverterUInt.allocationSize(value.`v`)
                )
        }
        is ZcashTxVersionSelection.Overwinter -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                )
        }
        is ZcashTxVersionSelection.Sapling -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                )
        }
        is ZcashTxVersionSelection.Zip225 -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                )
        }
    }

    override fun write(value: ZcashTxVersionSelection, buf: ByteBuffer) {
        when (value) {
            is ZcashTxVersionSelection.Sprout -> {
                buf.putInt(1)
                FfiConverterUInt.write(value.`v`, buf)
                Unit
            }
            is ZcashTxVersionSelection.Overwinter -> {
                buf.putInt(2)
                Unit
            }
            is ZcashTxVersionSelection.Sapling -> {
                buf.putInt(3)
                Unit
            }
            is ZcashTxVersionSelection.Zip225 -> {
                buf.putInt(4)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

sealed class ZcashException(message: String) : Exception(message) {
    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.
    class HdWalletException(message: String) : ZcashException(message)
    class DecodingException(message: String) : ZcashException(message)
    class DerivationException(message: String) : ZcashException(message)
    class InvalidAsk(message: String) : ZcashException(message)
    class InvalidNsk(message: String) : ZcashException(message)
    class Message(message: String) : ZcashException(message)
    class ArrayLengthMismatch(message: String) : ZcashException(message)
    class ValueOutOfRange(message: String) : ZcashException(message)
    class Secp256k1Exception(message: String) : ZcashException(message)
    class Bech32DecodeException(message: String) : ZcashException(message)
    class Bs58Exception(message: String) : ZcashException(message)
    class BuilderException(message: String) : ZcashException(message)
    class TransparentBuilderException(message: String) : ZcashException(message)
    class SaplingBuilderException(message: String) : ZcashException(message)
    class OrchardBuilderException(message: String) : ZcashException(message)
    class InsufficientFundsException(message: String) : ZcashException(message)
    class ChangeRequiredException(message: String) : ZcashException(message)
    class BalanceException(message: String) : ZcashException(message)
    class IoException(message: String) : ZcashException(message)
    class Unknown(message: String) : ZcashException(message)

    companion object ErrorHandler : CallStatusErrorHandler<ZcashException> {
        override fun lift(error_buf: RustBuffer.ByValue): ZcashException = FfiConverterTypeZcashError.lift(error_buf)
    }
}

public object FfiConverterTypeZcashError : FfiConverterRustBuffer<ZcashException> {
    override fun read(buf: ByteBuffer): ZcashException {
        return when (buf.getInt()) {
            1 -> ZcashException.HdWalletException(FfiConverterString.read(buf))
            2 -> ZcashException.DecodingException(FfiConverterString.read(buf))
            3 -> ZcashException.DerivationException(FfiConverterString.read(buf))
            4 -> ZcashException.InvalidAsk(FfiConverterString.read(buf))
            5 -> ZcashException.InvalidNsk(FfiConverterString.read(buf))
            6 -> ZcashException.Message(FfiConverterString.read(buf))
            7 -> ZcashException.ArrayLengthMismatch(FfiConverterString.read(buf))
            8 -> ZcashException.ValueOutOfRange(FfiConverterString.read(buf))
            9 -> ZcashException.Secp256k1Exception(FfiConverterString.read(buf))
            10 -> ZcashException.Bech32DecodeException(FfiConverterString.read(buf))
            11 -> ZcashException.Bs58Exception(FfiConverterString.read(buf))
            12 -> ZcashException.BuilderException(FfiConverterString.read(buf))
            13 -> ZcashException.TransparentBuilderException(FfiConverterString.read(buf))
            14 -> ZcashException.SaplingBuilderException(FfiConverterString.read(buf))
            15 -> ZcashException.OrchardBuilderException(FfiConverterString.read(buf))
            16 -> ZcashException.InsufficientFundsException(FfiConverterString.read(buf))
            17 -> ZcashException.ChangeRequiredException(FfiConverterString.read(buf))
            18 -> ZcashException.BalanceException(FfiConverterString.read(buf))
            19 -> ZcashException.IoException(FfiConverterString.read(buf))
            20 -> ZcashException.Unknown(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: ZcashException): Int {
        return 4
    }

    override fun write(value: ZcashException, buf: ByteBuffer) {
        when (value) {
            is ZcashException.HdWalletException -> {
                buf.putInt(1)
                Unit
            }
            is ZcashException.DecodingException -> {
                buf.putInt(2)
                Unit
            }
            is ZcashException.DerivationException -> {
                buf.putInt(3)
                Unit
            }
            is ZcashException.InvalidAsk -> {
                buf.putInt(4)
                Unit
            }
            is ZcashException.InvalidNsk -> {
                buf.putInt(5)
                Unit
            }
            is ZcashException.Message -> {
                buf.putInt(6)
                Unit
            }
            is ZcashException.ArrayLengthMismatch -> {
                buf.putInt(7)
                Unit
            }
            is ZcashException.ValueOutOfRange -> {
                buf.putInt(8)
                Unit
            }
            is ZcashException.Secp256k1Exception -> {
                buf.putInt(9)
                Unit
            }
            is ZcashException.Bech32DecodeException -> {
                buf.putInt(10)
                Unit
            }
            is ZcashException.Bs58Exception -> {
                buf.putInt(11)
                Unit
            }
            is ZcashException.BuilderException -> {
                buf.putInt(12)
                Unit
            }
            is ZcashException.TransparentBuilderException -> {
                buf.putInt(13)
                Unit
            }
            is ZcashException.SaplingBuilderException -> {
                buf.putInt(14)
                Unit
            }
            is ZcashException.OrchardBuilderException -> {
                buf.putInt(15)
                Unit
            }
            is ZcashException.InsufficientFundsException -> {
                buf.putInt(16)
                Unit
            }
            is ZcashException.ChangeRequiredException -> {
                buf.putInt(17)
                Unit
            }
            is ZcashException.BalanceException -> {
                buf.putInt(18)
                Unit
            }
            is ZcashException.IoException -> {
                buf.putInt(19)
                Unit
            }
            is ZcashException.Unknown -> {
                buf.putInt(20)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

public object FfiConverterOptionalULong : FfiConverterRustBuffer<ULong?> {
    override fun read(buf: ByteBuffer): ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: ULong?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}

public object FfiConverterOptionalString : FfiConverterRustBuffer<String?> {
    override fun read(buf: ByteBuffer): String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: String?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashAccountPubKey : FfiConverterRustBuffer<ZcashAccountPubKey?> {
    override fun read(buf: ByteBuffer): ZcashAccountPubKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashAccountPubKey.read(buf)
    }

    override fun allocationSize(value: ZcashAccountPubKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashAccountPubKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashAccountPubKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashAccountPubKey.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashDiversifiableFullViewingKey : FfiConverterRustBuffer<ZcashDiversifiableFullViewingKey?> {
    override fun read(buf: ByteBuffer): ZcashDiversifiableFullViewingKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashDiversifiableFullViewingKey.read(buf)
    }

    override fun allocationSize(value: ZcashDiversifiableFullViewingKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashDiversifiableFullViewingKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashDiversifiableFullViewingKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashDiversifiableFullViewingKey.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashMemoBytes : FfiConverterRustBuffer<ZcashMemoBytes?> {
    override fun read(buf: ByteBuffer): ZcashMemoBytes? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashMemoBytes.read(buf)
    }

    override fun allocationSize(value: ZcashMemoBytes?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashMemoBytes.allocationSize(value)
        }
    }

    override fun write(value: ZcashMemoBytes?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashMemoBytes.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashOrchardAddress : FfiConverterRustBuffer<ZcashOrchardAddress?> {
    override fun read(buf: ByteBuffer): ZcashOrchardAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardAddress.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardAddress.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashOrchardBundle : FfiConverterRustBuffer<ZcashOrchardBundle?> {
    override fun read(buf: ByteBuffer): ZcashOrchardBundle? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardBundle.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardBundle?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardBundle.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardBundle?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardBundle.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashOrchardDiversifierIndex : FfiConverterRustBuffer<ZcashOrchardDiversifierIndex?> {
    override fun read(buf: ByteBuffer): ZcashOrchardDiversifierIndex? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardDiversifierIndex.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardDiversifierIndex?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardDiversifierIndex.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardDiversifierIndex?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardDiversifierIndex.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashOrchardFullViewingKey : FfiConverterRustBuffer<ZcashOrchardFullViewingKey?> {
    override fun read(buf: ByteBuffer): ZcashOrchardFullViewingKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardFullViewingKey.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardFullViewingKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardFullViewingKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardFullViewingKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardFullViewingKey.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashOrchardOutgoingViewingKey : FfiConverterRustBuffer<ZcashOrchardOutgoingViewingKey?> {
    override fun read(buf: ByteBuffer): ZcashOrchardOutgoingViewingKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardOutgoingViewingKey.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardOutgoingViewingKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardOutgoingViewingKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardOutgoingViewingKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardOutgoingViewingKey.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashOutgoingViewingKey : FfiConverterRustBuffer<ZcashOutgoingViewingKey?> {
    override fun read(buf: ByteBuffer): ZcashOutgoingViewingKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOutgoingViewingKey.read(buf)
    }

    override fun allocationSize(value: ZcashOutgoingViewingKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOutgoingViewingKey.allocationSize(value)
        }
    }

    override fun write(value: ZcashOutgoingViewingKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOutgoingViewingKey.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashPaymentAddress : FfiConverterRustBuffer<ZcashPaymentAddress?> {
    override fun read(buf: ByteBuffer): ZcashPaymentAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashPaymentAddress.read(buf)
    }

    override fun allocationSize(value: ZcashPaymentAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashPaymentAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashPaymentAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashPaymentAddress.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashSaplingBundle : FfiConverterRustBuffer<ZcashSaplingBundle?> {
    override fun read(buf: ByteBuffer): ZcashSaplingBundle? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashSaplingBundle.read(buf)
    }

    override fun allocationSize(value: ZcashSaplingBundle?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashSaplingBundle.allocationSize(value)
        }
    }

    override fun write(value: ZcashSaplingBundle?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashSaplingBundle.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashSaplingMerklePath : FfiConverterRustBuffer<ZcashSaplingMerklePath?> {
    override fun read(buf: ByteBuffer): ZcashSaplingMerklePath? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashSaplingMerklePath.read(buf)
    }

    override fun allocationSize(value: ZcashSaplingMerklePath?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashSaplingMerklePath.allocationSize(value)
        }
    }

    override fun write(value: ZcashSaplingMerklePath?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashSaplingMerklePath.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashTransparentAddress : FfiConverterRustBuffer<ZcashTransparentAddress?> {
    override fun read(buf: ByteBuffer): ZcashTransparentAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashTransparentAddress.read(buf)
    }

    override fun allocationSize(value: ZcashTransparentAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashTransparentAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashTransparentAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashTransparentAddress.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashTransparentBundle : FfiConverterRustBuffer<ZcashTransparentBundle?> {
    override fun read(buf: ByteBuffer): ZcashTransparentBundle? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashTransparentBundle.read(buf)
    }

    override fun allocationSize(value: ZcashTransparentBundle?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashTransparentBundle.allocationSize(value)
        }
    }

    override fun write(value: ZcashTransparentBundle?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashTransparentBundle.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashUnifiedAddress : FfiConverterRustBuffer<ZcashUnifiedAddress?> {
    override fun read(buf: ByteBuffer): ZcashUnifiedAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashUnifiedAddress.read(buf)
    }

    override fun allocationSize(value: ZcashUnifiedAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashUnifiedAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashUnifiedAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashUnifiedAddress.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashDiversifierIndexAndPaymentAddress : FfiConverterRustBuffer<ZcashDiversifierIndexAndPaymentAddress?> {
    override fun read(buf: ByteBuffer): ZcashDiversifierIndexAndPaymentAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.read(buf)
    }

    override fun allocationSize(value: ZcashDiversifierIndexAndPaymentAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.allocationSize(value)
        }
    }

    override fun write(value: ZcashDiversifierIndexAndPaymentAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashDiversifierIndexAndPaymentAddress.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashDiversifierIndexAndScope : FfiConverterRustBuffer<ZcashDiversifierIndexAndScope?> {
    override fun read(buf: ByteBuffer): ZcashDiversifierIndexAndScope? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashDiversifierIndexAndScope.read(buf)
    }

    override fun allocationSize(value: ZcashDiversifierIndexAndScope?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashDiversifierIndexAndScope.allocationSize(value)
        }
    }

    override fun write(value: ZcashDiversifierIndexAndScope?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashDiversifierIndexAndScope.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashUnifiedAddressAndDiversifierIndex : FfiConverterRustBuffer<ZcashUnifiedAddressAndDiversifierIndex?> {
    override fun read(buf: ByteBuffer): ZcashUnifiedAddressAndDiversifierIndex? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.read(buf)
    }

    override fun allocationSize(value: ZcashUnifiedAddressAndDiversifierIndex?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.allocationSize(value)
        }
    }

    override fun write(value: ZcashUnifiedAddressAndDiversifierIndex?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashUnifiedAddressAndDiversifierIndex.write(value, buf)
        }
    }
}

public object FfiConverterOptionalTypeZcashOrchardScope : FfiConverterRustBuffer<ZcashOrchardScope?> {
    override fun read(buf: ByteBuffer): ZcashOrchardScope? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeZcashOrchardScope.read(buf)
    }

    override fun allocationSize(value: ZcashOrchardScope?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeZcashOrchardScope.allocationSize(value)
        }
    }

    override fun write(value: ZcashOrchardScope?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeZcashOrchardScope.write(value, buf)
        }
    }
}

public object FfiConverterOptionalSequenceUByte : FfiConverterRustBuffer<List<UByte>?> {
    override fun read(buf: ByteBuffer): List<UByte>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceUByte.read(buf)
    }

    override fun allocationSize(value: List<UByte>?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterSequenceUByte.allocationSize(value)
        }
    }

    override fun write(value: List<UByte>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceUByte.write(value, buf)
        }
    }
}

public object FfiConverterSequenceUByte : FfiConverterRustBuffer<List<UByte>> {
    override fun read(buf: ByteBuffer): List<UByte> {
        val len = buf.getInt()
        return List<UByte>(len) {
            FfiConverterUByte.read(buf)
        }
    }

    override fun allocationSize(value: List<UByte>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterUByte.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UByte>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterUByte.write(it, buf)
        }
    }
}

public object FfiConverterSequenceUInt : FfiConverterRustBuffer<List<UInt>> {
    override fun read(buf: ByteBuffer): List<UInt> {
        val len = buf.getInt()
        return List<UInt>(len) {
            FfiConverterUInt.read(buf)
        }
    }

    override fun allocationSize(value: List<UInt>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterUInt.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<UInt>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterUInt.write(it, buf)
        }
    }
}

public object FfiConverterSequenceULong : FfiConverterRustBuffer<List<ULong>> {
    override fun read(buf: ByteBuffer): List<ULong> {
        val len = buf.getInt()
        return List<ULong>(len) {
            FfiConverterULong.read(buf)
        }
    }

    override fun allocationSize(value: List<ULong>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterULong.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ULong>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterULong.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashOrchardAction : FfiConverterRustBuffer<List<ZcashOrchardAction>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardAction> {
        val len = buf.getInt()
        return List<ZcashOrchardAction>(len) {
            FfiConverterTypeZcashOrchardAction.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardAction>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardAction.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardAction>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardAction.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashOrchardIncomingViewingKey : FfiConverterRustBuffer<List<ZcashOrchardIncomingViewingKey>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardIncomingViewingKey> {
        val len = buf.getInt()
        return List<ZcashOrchardIncomingViewingKey>(len) {
            FfiConverterTypeZcashOrchardIncomingViewingKey.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardIncomingViewingKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardIncomingViewingKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardIncomingViewingKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardIncomingViewingKey.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashOrchardMerkleHash : FfiConverterRustBuffer<List<ZcashOrchardMerkleHash>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardMerkleHash> {
        val len = buf.getInt()
        return List<ZcashOrchardMerkleHash>(len) {
            FfiConverterTypeZcashOrchardMerkleHash.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardMerkleHash>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardMerkleHash.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardMerkleHash>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardMerkleHash.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashOrchardOutgoingViewingKey : FfiConverterRustBuffer<List<ZcashOrchardOutgoingViewingKey>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardOutgoingViewingKey> {
        val len = buf.getInt()
        return List<ZcashOrchardOutgoingViewingKey>(len) {
            FfiConverterTypeZcashOrchardOutgoingViewingKey.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardOutgoingViewingKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardOutgoingViewingKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardOutgoingViewingKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardOutgoingViewingKey.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashOrchardSpendingKey : FfiConverterRustBuffer<List<ZcashOrchardSpendingKey>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardSpendingKey> {
        val len = buf.getInt()
        return List<ZcashOrchardSpendingKey>(len) {
            FfiConverterTypeZcashOrchardSpendingKey.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardSpendingKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardSpendingKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardSpendingKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardSpendingKey.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashSaplingOutputDescription : FfiConverterRustBuffer<List<ZcashSaplingOutputDescription>> {
    override fun read(buf: ByteBuffer): List<ZcashSaplingOutputDescription> {
        val len = buf.getInt()
        return List<ZcashSaplingOutputDescription>(len) {
            FfiConverterTypeZcashSaplingOutputDescription.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashSaplingOutputDescription>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashSaplingOutputDescription.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashSaplingOutputDescription>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashSaplingOutputDescription.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashSaplingSpendDescription : FfiConverterRustBuffer<List<ZcashSaplingSpendDescription>> {
    override fun read(buf: ByteBuffer): List<ZcashSaplingSpendDescription> {
        val len = buf.getInt()
        return List<ZcashSaplingSpendDescription>(len) {
            FfiConverterTypeZcashSaplingSpendDescription.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashSaplingSpendDescription>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashSaplingSpendDescription.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashSaplingSpendDescription>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashSaplingSpendDescription.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashTxIn : FfiConverterRustBuffer<List<ZcashTxIn>> {
    override fun read(buf: ByteBuffer): List<ZcashTxIn> {
        val len = buf.getInt()
        return List<ZcashTxIn>(len) {
            FfiConverterTypeZcashTxIn.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashTxIn>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashTxIn.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashTxIn>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashTxIn.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashTxOut : FfiConverterRustBuffer<List<ZcashTxOut>> {
    override fun read(buf: ByteBuffer): List<ZcashTxOut> {
        val len = buf.getInt()
        return List<ZcashTxOut>(len) {
            FfiConverterTypeZcashTxOut.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashTxOut>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashTxOut.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashTxOut>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashTxOut.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashAuthPath : FfiConverterRustBuffer<List<ZcashAuthPath>> {
    override fun read(buf: ByteBuffer): List<ZcashAuthPath> {
        val len = buf.getInt()
        return List<ZcashAuthPath>(len) {
            FfiConverterTypeZcashAuthPath.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashAuthPath>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashAuthPath.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashAuthPath>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashAuthPath.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashOrchardDecryptOutputForIncomingKeys : FfiConverterRustBuffer<List<ZcashOrchardDecryptOutputForIncomingKeys>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardDecryptOutputForIncomingKeys> {
        val len = buf.getInt()
        return List<ZcashOrchardDecryptOutputForIncomingKeys>(len) {
            FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardDecryptOutputForIncomingKeys>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardDecryptOutputForIncomingKeys>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardDecryptOutputForIncomingKeys.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys : FfiConverterRustBuffer<List<ZcashOrchardDecryptOutputForOutgoingKeys>> {
    override fun read(buf: ByteBuffer): List<ZcashOrchardDecryptOutputForOutgoingKeys> {
        val len = buf.getInt()
        return List<ZcashOrchardDecryptOutputForOutgoingKeys>(len) {
            FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashOrchardDecryptOutputForOutgoingKeys>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashOrchardDecryptOutputForOutgoingKeys>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashOrchardDecryptOutputForOutgoingKeys.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashPaymentParam : FfiConverterRustBuffer<List<ZcashPaymentParam>> {
    override fun read(buf: ByteBuffer): List<ZcashPaymentParam> {
        val len = buf.getInt()
        return List<ZcashPaymentParam>(len) {
            FfiConverterTypeZcashPaymentParam.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashPaymentParam>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashPaymentParam.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashPaymentParam>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashPaymentParam.write(it, buf)
        }
    }
}

public object FfiConverterSequenceTypeZcashChildIndex : FfiConverterRustBuffer<List<ZcashChildIndex>> {
    override fun read(buf: ByteBuffer): List<ZcashChildIndex> {
        val len = buf.getInt()
        return List<ZcashChildIndex>(len) {
            FfiConverterTypeZcashChildIndex.read(buf)
        }
    }

    override fun allocationSize(value: List<ZcashChildIndex>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeZcashChildIndex.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ZcashChildIndex>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeZcashChildIndex.write(it, buf)
        }
    }
}

@Throws(ZcashException::class)
fun `decodeExtendedFullViewingKey`(`hrp`: String, `s`: String): ZcashExtendedFullViewingKey {
    return FfiConverterTypeZcashExtendedFullViewingKey.lift(
        rustCallWithError(ZcashException) { _status ->
            _UniFFILib.INSTANCE.zcash_e53_decode_extended_full_viewing_key(FfiConverterString.lower(`hrp`), FfiConverterString.lower(`s`), _status)
        },
    )
}

@Throws(ZcashException::class)
fun `decodeExtendedSpendingKey`(`hrp`: String, `s`: String): ZcashExtendedSpendingKey {
    return FfiConverterTypeZcashExtendedSpendingKey.lift(
        rustCallWithError(ZcashException) { _status ->
            _UniFFILib.INSTANCE.zcash_e53_decode_extended_spending_key(FfiConverterString.lower(`hrp`), FfiConverterString.lower(`s`), _status)
        },
    )
}

@Throws(ZcashException::class)
fun `decodePaymentAddress`(`hrp`: String, `s`: String): ZcashPaymentAddress {
    return FfiConverterTypeZcashPaymentAddress.lift(
        rustCallWithError(ZcashException) { _status ->
            _UniFFILib.INSTANCE.zcash_e53_decode_payment_address(FfiConverterString.lower(`hrp`), FfiConverterString.lower(`s`), _status)
        },
    )
}

@Throws(ZcashException::class)
fun `decodeTransparentAddress`(`pubkeyVersion`: List<UByte>, `scriptVersion`: List<UByte>, `s`: String): ZcashTransparentAddress {
    return FfiConverterTypeZcashTransparentAddress.lift(
        rustCallWithError(ZcashException) { _status ->
            _UniFFILib.INSTANCE.zcash_e53_decode_transparent_address(FfiConverterSequenceUByte.lower(`pubkeyVersion`), FfiConverterSequenceUByte.lower(`scriptVersion`), FfiConverterString.lower(`s`), _status)
        },
    )
}

fun `encodeExtendedFullViewingKey`(`hrp`: String, `extfvk`: ZcashExtendedFullViewingKey): String {
    return FfiConverterString.lift(
        rustCall() { _status ->
            _UniFFILib.INSTANCE.zcash_e53_encode_extended_full_viewing_key(FfiConverterString.lower(`hrp`), FfiConverterTypeZcashExtendedFullViewingKey.lower(`extfvk`), _status)
        },
    )
}

fun `encodeExtendedSpendingKey`(`hrp`: String, `extsk`: ZcashExtendedSpendingKey): String {
    return FfiConverterString.lift(
        rustCall() { _status ->
            _UniFFILib.INSTANCE.zcash_e53_encode_extended_spending_key(FfiConverterString.lower(`hrp`), FfiConverterTypeZcashExtendedSpendingKey.lower(`extsk`), _status)
        },
    )
}

fun `encodePaymentAddress`(`hrp`: String, `addr`: ZcashPaymentAddress): String {
    return FfiConverterString.lift(
        rustCall() { _status ->
            _UniFFILib.INSTANCE.zcash_e53_encode_payment_address(FfiConverterString.lower(`hrp`), FfiConverterTypeZcashPaymentAddress.lower(`addr`), _status)
        },
    )
}

fun `encodePaymentAddressP`(`params`: ZcashConsensusParameters, `addr`: ZcashPaymentAddress): String {
    return FfiConverterString.lift(
        rustCall() { _status ->
            _UniFFILib.INSTANCE.zcash_e53_encode_payment_address_p(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterTypeZcashPaymentAddress.lower(`addr`), _status)
        },
    )
}

fun `encodeTransparentAddress`(`pubkeyVersion`: List<UByte>, `scriptVersion`: List<UByte>, `addr`: ZcashTransparentAddress): String {
    return FfiConverterString.lift(
        rustCall() { _status ->
            _UniFFILib.INSTANCE.zcash_e53_encode_transparent_address(FfiConverterSequenceUByte.lower(`pubkeyVersion`), FfiConverterSequenceUByte.lower(`scriptVersion`), FfiConverterTypeZcashTransparentAddress.lower(`addr`), _status)
        },
    )
}

fun `encodeTransparentAddressP`(`params`: ZcashConsensusParameters, `addr`: ZcashTransparentAddress): String {
    return FfiConverterString.lift(
        rustCall() { _status ->
            _UniFFILib.INSTANCE.zcash_e53_encode_transparent_address_p(FfiConverterTypeZcashConsensusParameters.lower(`params`), FfiConverterTypeZcashTransparentAddress.lower(`addr`), _status)
        },
    )
}
